# lockedin-bundle-22.txt
# Bundle 22 — Messaging & Safety Layer (Real‑time DM + Youth-Safe Controls)
# Monorepo layout assumed from prior bundles:
# apps/web, services/*, packages/contracts, db/migrations
# No secrets included. Safe for public repos.

================================================================================
MANIFEST
================================================================================
name: lockedin-bundle-22
scope: "Messaging service + front-end chat UI + moderation hooks"
version: 0.1.0
includes:
  - services/messaging (Express + Socket.IO real-time API)
  - packages/contracts/messages.ts (shared types)
  - apps/web/features/messaging (React chat, thread list, message input)
  - apps/web/pages/Messages.tsx (route)
  - db/migrations/022_messages.sql (Postgres/SQLite compatible)
  - docs/INTEGRATION-messaging.md (setup and wiring guide)
compatibility:
  - Node 18+
  - TypeScript 5+
  - Postgres 13+ (or SQLite for dev)
  - Socket.IO v4
security/safety:
  - Youth-Safe mode: blocks external links, phone/email exchange, location sharing
  - Rate limits: per user per thread
  - Block/Report handling endpoints
  - Moderation hooks (sync) + async queue stub for future LLM moderation
notes:
  - Uses header `x-user-id` as mock auth in dev (replace with real auth in prod)
  - All env vars are optional with sensible dev defaults

================================================================================
FILE: services/messaging/package.json
================================================================================
{
  "name": "@lockedin/messaging",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "main": "dist/index.js",
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc -p tsconfig.json",
    "start": "node dist/index.js",
    "lint": "eslint ."
  },
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "helmet": "^7.1.0",
    "http-status-codes": "^2.3.0",
    "pino": "^9.0.0",
    "socket.io": "^4.7.5",
    "zod": "^3.23.8",
    "pg": "^8.12.0",
    "better-sqlite3": "^9.4.3",
    "sql-template-strings": "^2.2.2",
    "rate-limiter-flexible": "^5.0.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^20.11.30",
    "tsx": "^4.16.2",
    "typescript": "^5.4.5"
  }
}

================================================================================
FILE: services/messaging/tsconfig.json
================================================================================
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "module": "ESNext",
    "moduleResolution": "Node",
    "target": "ES2020",
    "strict": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "types": ["node"]
  },
  "include": ["src"]
}

================================================================================
FILE: services/messaging/src/index.ts
================================================================================
import 'dotenv/config';
import http from 'http';
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import pino from 'pino';
import { Server as IOServer } from 'socket.io';
import { StatusCodes } from 'http-status-codes';
import { z } from 'zod';
import { getDB, migrate } from './lib/db';
import { authMiddleware, getReqUser } from './lib/dev-auth';
import { moderation } from './lib/moderation';
import { MessageRepo } from './repos/MessageRepo';
import { ThreadRepo } from './repos/ThreadRepo';
import { presence } from './lib/presence';

const log = pino({ name: 'messaging' });

const app = express();
app.use(helmet());
app.use(cors({ origin: true, credentials: true }));
app.use(express.json({ limit: '1mb' }));
app.use(authMiddleware);

const server = http.createServer(app);
const io = new IOServer(server, {
  cors: { origin: true, credentials: true }
});

// ------------------- DB Init -------------------
await migrate(getDB());

// ------------------- Socket.IO -------------------
io.use(async (socket, next) => {
  const userId = socket.handshake.auth?.userId || socket.handshake.headers['x-user-id'];
  if (!userId || Array.isArray(userId)) {
    return next(new Error('UNAUTHORIZED'));
  }
  (socket as any).userId = String(userId);
  next();
});

io.on('connection', (socket) => {
  const userId: string = (socket as any).userId;
  presence.setOnline(userId, socket.id);
  log.info({ userId }, 'socket connected');

  socket.on('thread:join', (threadId: string) => {
    socket.join(`thread:${threadId}`);
  });

  socket.on('thread:leave', (threadId: string) => {
    socket.leave(`thread:${threadId}`);
  });

  socket.on('disconnect', () => {
    presence.setOffline(userId, socket.id);
    log.info({ userId }, 'socket disconnected');
  });
});

// ------------------- Schemas -------------------
const SendMessageSchema = z.object({
  threadId: z.string().uuid(),
  body: z.string().min(1).max(4000)
});

const CreateThreadSchema = z.object({
  participantIds: z.array(z.string()).min(1).max(15)
});

// ------------------- Repos -------------------
const messages = new MessageRepo(getDB());
const threads = new ThreadRepo(getDB());

// ------------------- REST API -------------------
app.get('/health', (_req, res) => res.json({ ok: true }));

// List threads for user
app.get('/v1/threads', async (req, res) => {
  const user = getReqUser(req);
  const data = await threads.listForUser(user.id);
  res.json({ threads: data });
});

// Create thread (or return existing 1:1)
app.post('/v1/threads', async (req, res) => {
  const user = getReqUser(req);
  const { participantIds } = CreateThreadSchema.parse(req.body);
  const ids = Array.from(new Set([user.id, ...participantIds].filter(Boolean)));
  const thread = await threads.upsert(ids);
  res.status(StatusCodes.CREATED).json({ thread });
});

// Get messages in a thread
app.get('/v1/threads/:id/messages', async (req, res) => {
  const user = getReqUser(req);
  const threadId = req.params.id;
  const ok = await threads.userInThread(threadId, user.id);
  if (!ok) return res.status(StatusCodes.FORBIDDEN).json({ error: 'Forbidden' });
  const list = await messages.list(threadId, 50);
  res.json({ messages: list });
});

// Send a message
app.post('/v1/messages', async (req, res) => {
  const user = getReqUser(req);
  const { threadId, body } = SendMessageSchema.parse(req.body);

  // authz
  const ok = await threads.userInThread(threadId, user.id);
  if (!ok) return res.status(StatusCodes.FORBIDDEN).json({ error: 'Forbidden' });

  // moderation + youth-safe checks
  const mod = moderation.validateMessage({ user, body });
  if (!mod.allowed) {
    return res.status(StatusCodes.BAD_REQUEST).json({ error: 'Message blocked', reasons: mod.reasons });
  }

  // rate limit (simple: 1 msg/sec per user per thread)
  const accepted = await messages.rateLimitOk(threadId, user.id);
  if (!accepted) {
    return res.status(StatusCodes.TOO_MANY_REQUESTS).json({ error: 'Too many messages' });
  }

  const saved = await messages.create(threadId, user.id, body, mod.tags);
  io.to(`thread:${threadId}`).emit('message:new', saved);
  res.status(StatusCodes.CREATED).json({ message: saved });
});

// mark as read
app.post('/v1/threads/:id/read', async (req, res) => {
  const user = getReqUser(req);
  const threadId = req.params.id;
  await messages.markRead(threadId, user.id);
  res.json({ ok: true });
});

// block/report
app.post('/v1/threads/:id/block', async (req, res) => {
  const user = getReqUser(req);
  await threads.block(req.params.id, user.id);
  res.json({ ok: true });
});

app.post('/v1/threads/:id/report', async (req, res) => {
  const user = getReqUser(req);
  await threads.report(req.params.id, user.id, String(req.body?.reason || 'unspecified'));
  res.json({ ok: true });
});

// ------------------- Start -------------------
const PORT = Number(process.env.PORT || 4012);
server.listen(PORT, () => log.info({ PORT }, 'messaging service listening'));

================================================================================
FILE: services/messaging/src/lib/db.ts
================================================================================
import Database from 'better-sqlite3';
import { Client as PGClient } from 'pg';

type DB = Database.Database & { kind: 'sqlite' } | (PGClient & { kind: 'pg' });

let sqlite: Database.Database | null = null;
let pg: PGClient | null = null;

export function getDB(): DB {
  const url = process.env.DATABASE_URL;
  if (!url || url.startsWith('sqlite:') || url === 'dev') {
    if (!sqlite) {
      sqlite = new Database(':memory:');
      (sqlite as any).kind = 'sqlite';
    }
    return sqlite as any;
  } else {
    if (!pg) {
      pg = new PGClient({ connectionString: url });
      (pg as any).kind = 'pg';
      pg.connect();
    }
    return pg as any;
  }
}

export async function migrate(db: DB) {
  const sql = `
  CREATE TABLE IF NOT EXISTS threads (
    id TEXT PRIMARY KEY,
    participant_ids TEXT NOT NULL, -- JSON array
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );
  CREATE TABLE IF NOT EXISTS messages (
    id TEXT PRIMARY KEY,
    thread_id TEXT NOT NULL,
    sender_id TEXT NOT NULL,
    body TEXT NOT NULL,
    tags TEXT NOT NULL, -- JSON array
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );
  CREATE TABLE IF NOT EXISTS receipts (
    thread_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    last_read_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (thread_id, user_id)
  );
  CREATE TABLE IF NOT EXISTS blocks (
    thread_id TEXT NOT NULL,
    blocker_id TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (thread_id, blocker_id)
  );
  CREATE TABLE IF NOT EXISTS reports (
    id TEXT PRIMARY KEY,
    thread_id TEXT NOT NULL,
    reporter_id TEXT NOT NULL,
    reason TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );
  `;
  if ((db as any).kind === 'sqlite') {
    (db as any).exec(sql);
  } else {
    await (db as any).query(sql);
  }
}

export async function query(db: DB, sql: string, params: any[] = []) {
  if ((db as any).kind === 'sqlite') {
    const stmt = (db as any).prepare(sql);
    if (sql.trim().toLowerCase().startsWith('select')) {
      return stmt.all(...params);
    } else {
      return stmt.run(...params);
    }
  } else {
    const res = await (db as any).query(sql, params);
    return res.rows ?? [];
  }
}

================================================================================
FILE: services/messaging/src/lib/dev-auth.ts
================================================================================
import { Request, Response, NextFunction } from 'express';

export function authMiddleware(req: Request, _res: Response, next: NextFunction) {
  // DEV ONLY: grab user from header, cookie, or default
  const uid = (req.headers['x-user-id'] as string) || 'dev-user-001';
  (req as any).user = { id: uid, age_mode: req.headers['x-age-mode'] || 'ADULT' };
  next();
}

export function getReqUser(req: Request) {
  return (req as any).user as { id: string; age_mode: 'ADULT' | 'YOUTH' };
}

================================================================================
FILE: services/messaging/src/lib/moderation.ts
================================================================================
const URL_REGEX = /(https?:\/\/|www\.)\S+/i;
const EMAIL_REGEX = /\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/i;
const PHONE_REGEX = /(\+?\d[\d\s().-]{7,}\d)/;

type User = { id: string; age_mode: 'ADULT' | 'YOUTH' };

export const moderation = {
  validateMessage({ user, body }: { user: User; body: string }) {
    const reasons: string[] = [];
    const tags: string[] = [];

    if (user.age_mode === 'YOUTH') {
      if (URL_REGEX.test(body)) { reasons.push('links_disallowed_for_youth'); tags.push('link'); }
      if (EMAIL_REGEX.test(body)) { reasons.push('no_email_exchange_for_youth'); tags.push('email'); }
      if (PHONE_REGEX.test(body)) { reasons.push('no_phone_exchange_for_youth'); tags.push('phone'); }
      const meetWords = /(meet|hang ?out|in person|address|location)/i;
      if (meetWords.test(body)) { reasons.push('no_meetup_for_youth'); tags.push('meetup'); }
    }

    // soft filters for everyone
    const profanity = /(damn|shit|fuck)/i;
    if (profanity.test(body)) tags.push('profanity');

    const allowed = reasons.length === 0;
    return { allowed, reasons, tags };
  }
};

================================================================================
FILE: services/messaging/src/lib/presence.ts
================================================================================
const online = new Map<string, Set<string>>(); // userId -> socketIds

export const presence = {
  setOnline(userId: string, socketId: string) {
    if (!online.has(userId)) online.set(userId, new Set());
    online.get(userId)!.add(socketId);
  },
  setOffline(userId: string, socketId: string) {
    const set = online.get(userId);
    if (!set) return;
    set.delete(socketId);
    if (set.size === 0) online.delete(userId);
  },
  isOnline(userId: string) {
    return online.has(userId);
  }
};

================================================================================
FILE: services/messaging/src/repos/ThreadRepo.ts
================================================================================
import { randomUUID } from 'node:crypto';
import { query, getDB } from '../lib/db';

export class ThreadRepo {
  constructor(private db = getDB()) {}

  async listForUser(userId: string) {
    const rows = await query(this.db, `
      SELECT id, participant_ids, created_at
      FROM threads
      WHERE json_extract(participant_ids, '$') LIKE '%' || ? || '%'
      ORDER BY created_at DESC
    `, [userId]);
    return rows.map((r: any) => ({
      id: r.id,
      participants: JSON.parse(r.participant_ids),
      created_at: r.created_at
    }));
  }

  async upsert(participantIds: string[]) {
    const sorted = [...participantIds].sort();
    // naive: try to find existing by exact set match
    const rows = await query(this.db, `
      SELECT id, participant_ids FROM threads
    `);
    for (const r of rows as any[]) {
      const ids = JSON.parse(r.participant_ids).sort();
      if (JSON.stringify(ids) === JSON.stringify(sorted)) {
        return { id: r.id, participants: ids };
      }
    }
    const id = randomUUID();
    await query(this.db, `
      INSERT INTO threads (id, participant_ids) VALUES (?, ?)
    `, [id, JSON.stringify(sorted)]);
    return { id, participants: sorted };
  }

  async userInThread(threadId: string, userId: string) {
    const rows = await query(this.db, `SELECT participant_ids FROM threads WHERE id = ?`, [threadId]);
    if (!rows.length) return false;
    const ids = JSON.parse(rows[0].participant_ids);
    return ids.includes(userId);
  }

  async block(threadId: string, blockerId: string) {
    await query(this.db, `INSERT OR REPLACE INTO blocks (thread_id, blocker_id) VALUES (?, ?)`, [threadId, blockerId]);
  }

  async report(threadId: string, reporterId: string, reason: string) {
    await query(this.db, `INSERT INTO reports (id, thread_id, reporter_id, reason) VALUES (?, ?, ?, ?)`,
      [randomUUID(), threadId, reporterId, reason]);
  }
}

================================================================================
FILE: services/messaging/src/repos/MessageRepo.ts
================================================================================
import { randomUUID } from 'node:crypto';
import { query, getDB } from '../lib/db';

const RATE_WINDOW_MS = 1000; // 1 second

export class MessageRepo {
  private recent: Map<string, number> = new Map(); // key: thread:user -> ts

  constructor(private db = getDB()) {}

  async list(threadId: string, limit = 50) {
    const rows = await query(this.db, `
      SELECT id, thread_id, sender_id, body, tags, created_at
      FROM messages
      WHERE thread_id = ?
      ORDER BY created_at DESC
      LIMIT ?
    `, [threadId, limit]);
    return rows.reverse().map((r: any) => ({
      id: r.id,
      thread_id: r.thread_id,
      sender_id: r.sender_id,
      body: r.body,
      tags: JSON.parse(r.tags),
      created_at: r.created_at
    }));
  }

  async create(threadId: string, senderId: string, body: string, tags: string[]) {
    const id = randomUUID();
    await query(this.db, `
      INSERT INTO messages (id, thread_id, sender_id, body, tags) VALUES (?, ?, ?, ?, ?)
    `, [id, threadId, senderId, body, JSON.stringify(tags)]);
    return { id, thread_id: threadId, sender_id: senderId, body, tags, created_at: new Date().toISOString() };
  }

  async markRead(threadId: string, userId: string) {
    await query(this.db, `
      INSERT OR REPLACE INTO receipts (thread_id, user_id, last_read_at)
      VALUES (?, ?, CURRENT_TIMESTAMP)
    `, [threadId, userId]);
  }

  async rateLimitOk(threadId: string, userId: string) {
    const key = `${threadId}:${userId}`;
    const now = Date.now();
    const last = this.recent.get(key) || 0;
    if (now - last < RATE_WINDOW_MS) return false;
    this.recent.set(key, now);
    return true;
  }
}

================================================================================
FILE: packages/contracts/src/messages.ts
================================================================================
export type Thread = {
  id: string;
  participants: string[];
  created_at: string;
};

export type Message = {
  id: string;
  thread_id: string;
  sender_id: string;
  body: string;
  tags: string[];
  created_at: string;
};

================================================================================
FILE: apps/web/src/features/messaging/api/messagesApi.ts
================================================================================
import type { Thread, Message } from '@lockedin/contracts/messages';

const BASE = import.meta.env.VITE_MESSAGING_URL || 'http://localhost:4012';

function headers() {
  const h: Record<string, string> = { 'Content-Type': 'application/json' };
  // DEV: user id header to simulate auth
  h['x-user-id'] = window.localStorage.getItem('dev_user_id') || 'dev-user-001';
  h['x-age-mode'] = window.localStorage.getItem('dev_age_mode') || 'ADULT';
  return h;
}

export async function listThreads(): Promise<Thread[]> {
  const r = await fetch(`${BASE}/v1/threads`, { credentials: 'include', headers: headers() });
  const j = await r.json();
  return j.threads;
}

export async function createThread(participantIds: string[]): Promise<Thread> {
  const r = await fetch(`${BASE}/v1/threads`, {
    method: 'POST',
    credentials: 'include',
    headers: headers(),
    body: JSON.stringify({ participantIds })
  });
  const j = await r.json();
  return j.thread;
}

export async function listMessages(threadId: string): Promise<Message[]> {
  const r = await fetch(`${BASE}/v1/threads/${threadId}/messages`, { credentials: 'include', headers: headers() });
  const j = await r.json();
  return j.messages;
}

export async function sendMessage(threadId: string, body: string): Promise<Message> {
  const r = await fetch(`${BASE}/v1/messages`, {
    method: 'POST',
    credentials: 'include',
    headers: headers(),
    body: JSON.stringify({ threadId, body })
  });
  if (!r.ok) {
    const err = await r.json().catch(() => ({}));
    throw new Error(err.error || 'Failed to send');
  }
  const j = await r.json();
  return j.message;
}

export async function markRead(threadId: string) {
  await fetch(`${BASE}/v1/threads/${threadId}/read`, {
    method: 'POST',
    credentials: 'include',
    headers: headers()
  });
}

export async function blockThread(threadId: string) {
  await fetch(`${BASE}/v1/threads/${threadId}/block`, {
    method: 'POST',
    credentials: 'include',
    headers: headers()
  });
}

export async function reportThread(threadId: string, reason: string) {
  await fetch(`${BASE}/v1/threads/${threadId}/report`, {
    method: 'POST',
    credentials: 'include',
    headers: headers(),
    body: JSON.stringify({ reason })
  });
}

================================================================================
FILE: apps/web/src/features/messaging/socket/useSocket.ts
================================================================================
import { io, Socket } from 'socket.io-client';

let socket: Socket | null = null;

export function getSocket(): Socket {
  if (socket) return socket;
  const url = import.meta.env.VITE_MESSAGING_URL || 'http://localhost:4012';
  socket = io(url, {
    auth: {
      userId: window.localStorage.getItem('dev_user_id') || 'dev-user-001'
    },
    transports: ['websocket']
  });
  return socket;
}

================================================================================
FILE: apps/web/src/features/messaging/components/ThreadList.tsx
================================================================================
import React, { useEffect, useState } from 'react';
import { listThreads } from '../api/messagesApi';
import type { Thread } from '@lockedin/contracts/messages';

type Props = {
  activeId?: string;
  onSelect: (id: string) => void;
};

export function ThreadList({ activeId, onSelect }: Props) {
  const [threads, setThreads] = useState<Thread[]>([]);

  useEffect(() => { listThreads().then(setThreads); }, []);

  return (
    <div className="border-r border-gray-200/60">
      <div className="p-4 font-semibold text-gray-700">Messages</div>
      <ul>
        {threads.map(t => (
          <li key={t.id}>
            <button
              onClick={() => onSelect(t.id)}
              className={`w-full text-left px-4 py-3 hover:bg-indigo-50 transition ${
                activeId === t.id ? 'bg-indigo-50 text-indigo-800' : 'text-gray-700'
              }`}
            >
              <div className="text-sm font-medium truncate">Thread: {t.participants.join(', ')}</div>
              <div className="text-xs text-gray-500">Created {new Date(t.created_at).toLocaleString()}</div>
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}

================================================================================
FILE: apps/web/src/features/messaging/components/MessageInput.tsx
================================================================================
import React, { useState } from 'react';

type Props = {
  onSend: (text: string) => Promise<void>;
  youthSafe?: boolean;
};

export function MessageInput({ onSend, youthSafe }: Props) {
  const [text, setText] = useState('');
  const [err, setErr] = useState<string | null>(null);
  const [sending, setSending] = useState(false);

  async function handleSend() {
    if (!text.trim()) return;
    setSending(true);
    setErr(null);
    try {
      await onSend(text.trim());
      setText('');
    } catch (e: any) {
      setErr(e.message || 'Failed to send');
    } finally {
      setSending(false);
    }
  }

  return (
    <div className="p-3 border-t border-gray-200/60 bg-white/80 backdrop-blur">
      {youthSafe && (
        <div className="text-xs text-emerald-700 mb-2">
          Youth-Safe: links, emails, phone numbers, and meetups are blocked.
        </div>
      )}
      <div className="flex gap-2">
        <textarea
          className="flex-1 p-3 border rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-300"
          placeholder="Write a message…"
          value={text}
          onChange={e => setText(e.target.value)}
          rows={2}
        />
        <button
          onClick={handleSend}
          disabled={sending}
          className="px-4 py-2 bg-indigo-600 text-white rounded-xl shadow hover:bg-indigo-700 disabled:opacity-60"
        >
          {sending ? 'Sending…' : 'Send'}
        </button>
      </div>
      {err && <div className="text-sm text-red-600 mt-2">{err}</div>}
    </div>
  );
}

================================================================================
FILE: apps/web/src/features/messaging/components/ChatWindow.tsx
================================================================================
import React, { useEffect, useRef, useState } from 'react';
import { listMessages, sendMessage, markRead } from '../api/messagesApi';
import { getSocket } from '../socket/useSocket';
import type { Message } from '@lockedin/contracts/messages';

type Props = {
  threadId: string;
  youthSafe?: boolean;
};

export function ChatWindow({ threadId, youthSafe }: Props) {
  const [msgs, setMsgs] = useState<Message[]>([]);
  const bottomRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    listMessages(threadId).then(setMsgs);
    const s = getSocket();
    s.emit('thread:join', threadId);
    s.on('message:new', (m: Message) => {
      if (m.thread_id === threadId) setMsgs(prev => [...prev, m]);
    });
    markRead(threadId);
    return () => {
      s.emit('thread:leave', threadId);
      s.off('message:new');
    };
  }, [threadId]);

  useEffect(() => { bottomRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [msgs.length]);

  async function handleSend(text: string) {
    const m = await sendMessage(threadId, text);
    setMsgs(prev => [...prev, m]);
  }

  return (
    <div className="flex flex-col h-full">
      <div className="flex-1 overflow-y-auto p-4 space-y-3 bg-gradient-to-br from-gray-50 to-blue-50">
        {msgs.map(m => (
          <div key={m.id} className="max-w-[75%] bg-white shadow border border-gray-200/60 rounded-2xl px-4 py-2">
            <div className="text-xs text-gray-500">{new Date(m.created_at).toLocaleTimeString()}</div>
            <div className="text-sm text-gray-800 whitespace-pre-wrap">{m.body}</div>
            {m.tags?.length ? (
              <div className="mt-1 flex gap-1 flex-wrap">
                {m.tags.map(t => (
                  <span key={t} className="text-[10px] px-1.5 py-0.5 bg-gray-100 rounded">{t}</span>
                ))}
              </div>
            ) : null}
          </div>
        ))}
        <div ref={bottomRef} />
      </div>
      {/* Message input */}
      {/* eslint-disable-next-line react/no-unknown-property */}
      <MessageInput onSend={handleSend} youthSafe={youthSafe} />
    </div>
  );
}

// internal component import (co-located)
import { MessageInput } from './MessageInput';

================================================================================
FILE: apps/web/src/pages/Messages.tsx
================================================================================
import React, { useEffect, useState } from 'react';
import { ThreadList } from '../features/messaging/components/ThreadList';
import { ChatWindow } from '../features/messaging/components/ChatWindow';

export default function MessagesPage() {
  const [active, setActive] = useState<string | undefined>(undefined);
  const youthSafe = (window.localStorage.getItem('dev_age_mode') || 'ADULT') === 'YOUTH';

  useEffect(() => {
    // Allow deep-link thread via URL hash: #thread=<id>
    const m = /thread=([^&]+)/.exec(window.location.hash);
    if (m) setActive(m[1]);
  }, []);

  return (
    <div className="h-[calc(100vh-4rem)] bg-white/80 backdrop-blur rounded-xl shadow border border-gray-200/60 grid grid-cols-3">
      <ThreadList activeId={active} onSelect={setActive} />
      <div className="col-span-2">
        {active ? (
          <ChatWindow threadId={active} youthSafe={youthSafe} />
        ) : (
          <div className="h-full flex items-center justify-center text-gray-500">Select a thread to start messaging</div>
        )}
      </div>
    </div>
  );
}

================================================================================
FILE: db/migrations/022_messages.sql
================================================================================
-- Postgres-compatible schema (SQLite dev tables are created in-code)
CREATE TABLE IF NOT EXISTS threads (
  id UUID PRIMARY KEY,
  participant_ids JSONB NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE IF NOT EXISTS messages (
  id UUID PRIMARY KEY,
  thread_id UUID NOT NULL REFERENCES threads(id) ON DELETE CASCADE,
  sender_id TEXT NOT NULL,
  body TEXT NOT NULL,
  tags JSONB NOT NULL DEFAULT '[]'::jsonb,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_messages_thread_created ON messages (thread_id, created_at);
CREATE INDEX IF NOT EXISTS idx_threads_participants ON threads USING GIN (participant_ids);

CREATE TABLE IF NOT EXISTS receipts (
  thread_id UUID NOT NULL REFERENCES threads(id) ON DELETE CASCADE,
  user_id TEXT NOT NULL,
  last_read_at TIMESTAMPTZ DEFAULT now(),
  PRIMARY KEY (thread_id, user_id)
);

CREATE TABLE IF NOT EXISTS blocks (
  thread_id UUID NOT NULL REFERENCES threads(id) ON DELETE CASCADE,
  blocker_id TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  PRIMARY KEY (thread_id, blocker_id)
);

CREATE TABLE IF NOT EXISTS reports (
  id UUID PRIMARY KEY,
  thread_id UUID NOT NULL REFERENCES threads(id) ON DELETE CASCADE,
  reporter_id TEXT NOT NULL,
  reason TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now()
);

================================================================================
FILE: docs/INTEGRATION-messaging.md
================================================================================
# Messaging Service — Integration Guide (Bundle 22)

## Overview
This bundle adds real-time, youth-safe direct messaging with block/report flows and a minimal chat UI. It’s split into a service (`services/messaging`) and web UI (`apps/web/...`). No secrets are embedded; dev mode uses headers to simulate auth.

## Run locally
```bash
# From repo root
pnpm i

# Env (optional)
export PORT=4012
# export DATABASE_URL=postgres://user:pass@localhost:5432/lockedin

# Start messaging service
pnpm --filter @lockedin/messaging dev

# Start web (assuming existing app shell)
pnpm --filter @lockedin/web dev
```

In the browser dev console, set a user and age mode to simulate:
```js
localStorage.setItem('dev_user_id', 'user-a');
localStorage.setItem('dev_age_mode', 'YOUTH'); // or 'ADULT'
```

## Routing
Add a route to your router:
```tsx
// apps/web/src/AppRoutes.tsx
<Route path="/messages" element={<MessagesPage />} />
```

## Youth-Safe rules (default)
- Blocks links, email addresses, phone numbers, and meetup/location language for users in `YOUTH` mode.
- Adults are allowed but still lightly tagged for profanity.
- Customize in `services/messaging/src/lib/moderation.ts`.

## Production auth
Replace `dev-auth.ts` with your real auth (JWT/session) and remove `x-user-id` usage on the web client. Ensure server-side authorization that a user belongs to the thread before allowing reads/sends.

## Scaling notes
- Replace in-memory rate limiter with Redis.
- Persist presence in Redis for multi-instance Socket.IO (use adapter).
- Move moderation to a job queue for async LLM screening if desired.

## API summary
- `GET /v1/threads` → list user threads
- `POST /v1/threads` `{ participantIds: string[] }` → create/upsert thread
- `GET /v1/threads/:id/messages` → list messages
- `POST /v1/messages` `{ threadId, body }` → send (moderation + rate limit)
- `POST /v1/threads/:id/read` → mark read
- `POST /v1/threads/:id/block` → block
- `POST /v1/threads/:id/report` `{ reason }` → report

---

This bundle is self-contained and does not change prior bundles.
