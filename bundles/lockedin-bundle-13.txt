# LockedIn â€” Bundle 13: Applications & Tracker (Backend + SDK + Web)
# Drop this into your repo and place files by the === path: ... === markers.
# No secrets are included. Uses your existing auth stub (must set req.user.id).

=== path: packages/api/src/modules/applications/application.types.ts ===
import { z } from "zod";

export const ApplicationStatus = z.enum([
  "SAVED",
  "DRAFTED",
  "APPLIED",
  "INTERVIEW",
  "OFFER",
  "REJECTED",
]);

export type ApplicationStatusT = z.infer<typeof ApplicationStatus>;

export const CreateApplicationInput = z.object({
  jobId: z.string(),
  status: ApplicationStatus.default("SAVED"),
  coverLetter: z.string().optional(),
  tailoredResume: z.any().optional(),
  notes: z.string().optional(),
});

export const UpdateApplicationInput = z.object({
  status: ApplicationStatus.optional(),
  coverLetter: z.string().optional(),
  tailoredResume: z.any().optional(),
  notes: z.string().optional(),
  interviewDate: z.coerce.date().optional(),
});

export type CreateApplicationDTO = z.infer<typeof CreateApplicationInput>;
export type UpdateApplicationDTO = z.infer<typeof UpdateApplicationInput>;

export interface AuthedRequestUser {
  id: string;
  ageMode?: "YOUTH" | "ADULT";
}

=== path: packages/api/src/modules/applications/application.service.ts ===
import { PrismaClient } from "@prisma/client";
import type { CreateApplicationDTO, UpdateApplicationDTO, ApplicationStatusT } from "./application.types";

const prisma = new PrismaClient();

export const ApplicationService = {
  async listByUser(userId: string) {
    return prisma.application.findMany({
      where: { userId },
      orderBy: { createdAt: "desc" },
      include: { job: true, events: true },
    });
  },

  async getById(id: string, userId: string) {
    const app = await prisma.application.findUnique({
      where: { id },
      include: { job: true, events: true },
    });
    if (!app || app.userId !== userId) return null;
    return app;
  },

  async create(userId: string, dto: CreateApplicationDTO) {
    // Ensure (userId, jobId) is unique
    const existing = await prisma.application.findFirst({
      where: { userId, jobId: dto.jobId },
    });
    if (existing) return existing;

    const app = await prisma.application.create({
      data: {
        userId,
        jobId: dto.jobId,
        status: dto.status ?? "SAVED",
        coverLetter: dto.coverLetter,
        tailoredResume: dto.tailoredResume as any,
        notes: dto.notes,
        events: {
          create: [
            { type: "CREATED", description: "Application created" },
            { type: "STATUS", description: `Status set to ${dto.status ?? "SAVED"}` },
          ],
        },
      },
      include: { job: true, events: true },
    });

    return app;
  },

  async update(id: string, userId: string, dto: UpdateApplicationDTO) {
    const existing = await this.getById(id, userId);
    if (!existing) return null;

    const app = await prisma.application.update({
      where: { id },
      data: {
        status: dto.status ?? existing.status,
        coverLetter: dto.coverLetter ?? existing.coverLetter,
        tailoredResume: (dto.tailoredResume as any) ?? existing.tailoredResume,
        notes: dto.notes ?? existing.notes,
        interviewDate: dto.interviewDate ?? existing.interviewDate,
        events: dto.status
          ? {
              create: [
                { type: "STATUS", description: `Status set to ${dto.status}` },
              ],
            }
          : undefined,
      },
      include: { job: true, events: true },
    });

    return app;
  },

  async setStatus(id: string, userId: string, status: ApplicationStatusT) {
    return this.update(id, userId, { status });
  },
};

=== path: packages/api/src/modules/applications/application.routes.ts ===
import { Router, Request, Response } from "express";
import { ApplicationService } from "./application.service";
import { CreateApplicationInput, UpdateApplicationInput, ApplicationStatus } from "./application.types";

// Expect upstream auth middleware to set req.user
function requireAuth(req: Request, res: Response, next: Function) {
  const u: any = (req as any).user;
  if (!u?.id) return res.status(401).json({ error: "Unauthorized" });
  next();
}

export const applicationRouter = Router();

// GET /applications - list current user's applications
applicationRouter.get("/", requireAuth, async (req, res) => {
  const userId = (req as any).user.id as string;
  const apps = await ApplicationService.listByUser(userId);
  res.json(apps);
});

// GET /applications/:id
applicationRouter.get("/:id", requireAuth, async (req, res) => {
  const userId = (req as any).user.id as string;
  const app = await ApplicationService.getById(req.params.id, userId);
  if (!app) return res.status(404).json({ error: "Not found" });
  res.json(app);
});

// POST /applications
applicationRouter.post("/", requireAuth, async (req, res) => {
  try {
    const parsed = CreateApplicationInput.parse(req.body);
    const userId = (req as any).user.id as string;
    const app = await ApplicationService.create(userId, parsed);
    res.status(201).json(app);
  } catch (e: any) {
    res.status(400).json({ error: e?.message ?? "Bad request" });
  }
});

// PATCH /applications/:id
applicationRouter.patch("/:id", requireAuth, async (req, res) => {
  try {
    const parsed = UpdateApplicationInput.parse(req.body);
    const userId = (req as any).user.id as string;
    const app = await ApplicationService.update(req.params.id, userId, parsed);
    if (!app) return res.status(404).json({ error: "Not found" });
    res.json(app);
  } catch (e: any) {
    res.status(400).json({ error: e?.message ?? "Bad request" });
  }
});

// POST /applications/:id/status
applicationRouter.post("/:id/status", requireAuth, async (req, res) => {
  try {
    const parsed = ApplicationStatus.parse(req.body?.status);
    const userId = (req as any).user.id as string;
    const app = await ApplicationService.setStatus(req.params.id, userId, parsed);
    if (!app) return res.status(404).json({ error: "Not found" });
    res.json(app);
  } catch (e: any) {
    res.status(400).json({ error: e?.message ?? "Bad request" });
  }
});

=== path: packages/api/src/modules/applications/index.ts ===
export * from "./application.routes";

=== path: packages/api/src/server.ts (PATCH) ===
// Add this snippet where you compose routers (keep your existing imports)
/*
import express from "express";
import cors from "cors";
import { applicationRouter } from "./modules/applications";
const app = express();
app.use(cors());
app.use(express.json());
app.use("/applications", applicationRouter);
app.listen(process.env.PORT || 4000, () => console.log("API listening"));
*/
// If you already have a server, just ensure:
// app.use("/applications", applicationRouter);

=== path: packages/api/prisma/schema-partial.application.prisma ===
// Merge this model into your Prisma schema and run a migration.
// Assumes you already have User and Job models.

enum ApplicationStatus {
  SAVED
  DRAFTED
  APPLIED
  INTERVIEW
  OFFER
  REJECTED
}

model Application {
  id             String            @id @default(cuid())
  userId         String
  jobId          String
  status         ApplicationStatus @default(SAVED)
  coverLetter    String?
  tailoredResume Json?
  fitScore       Int?
  keywordMatches String[]
  missingKeywords String[]
  notes          String?
  interviewDate  DateTime?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id])
  job  Job  @relation(fields: [jobId], references: [id])

  events ApplicationEvent[]

  @@unique([userId, jobId], name: "user_job_unique")
  @@index([userId, status, createdAt], name: "idx_applications_user_status_created")
}

model ApplicationEvent {
  id          String   @id @default(cuid())
  applicationId String
  type        String
  description String?
  date        DateTime @default(now())
  createdAt   DateTime @default(now())

  application Application @relation(fields: [applicationId], references: [id])

  @@index([applicationId, date], name: "idx_application_events")
}

=== path: packages/sdk/src/applications.ts ===
import type { ApplicationStatusT } from "../../api/src/modules/applications/application.types";

export interface LockedInSDKOptions {
  baseUrl?: string; // e.g., http://localhost:4000
  getAuthToken?: () => Promise<string | undefined> | string | undefined;
}

export class ApplicationsSDK {
  private baseUrl: string;
  private getAuthToken?: LockedInSDKOptions["getAuthToken"];
  constructor(opts: LockedInSDKOptions = {}) {
    this.baseUrl = (opts.baseUrl || process.env.NEXT_PUBLIC_API_URL || "http://localhost:4000").replace(/\/$/, "");
    this.getAuthToken = opts.getAuthToken;
  }

  private async req(path: string, init?: RequestInit) {
    const headers: Record<string, string> = { "Content-Type": "application/json" };
    const token = this.getAuthToken ? await this.getAuthToken() : undefined;
    if (token) headers["Authorization"] = `Bearer ${token}`;
    const res = await fetch(`${this.baseUrl}${path}`, { ...init, headers: { ...headers, ...(init?.headers as any) } });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  }

  list() {
    return this.req("/applications");
  }

  get(id: string) {
    return this.req(`/applications/${id}`);
  }

  create(input: { jobId: string; status?: ApplicationStatusT; coverLetter?: string; tailoredResume?: any; notes?: string; }) {
    return this.req("/applications", { method: "POST", body: JSON.stringify(input) });
  }

  update(id: string, input: Partial<{ status: ApplicationStatusT; coverLetter: string; tailoredResume: any; notes: string; interviewDate: string; }>) {
    return this.req(`/applications/${id}`, { method: "PATCH", body: JSON.stringify(input) });
  }

  setStatus(id: string, status: ApplicationStatusT) {
    return this.req(`/applications/${id}/status`, { method: "POST", body: JSON.stringify({ status }) });
  }
}

=== path: apps/web/src/lib/sdk.ts ===
import { ApplicationsSDK } from "../../../packages/sdk/src/applications";

export const sdk = {
  applications: new ApplicationsSDK({
    // Provide a token getter if you have auth; stub is fine in dev
    getAuthToken: () => undefined,
  }),
};

=== path: apps/web/src/pages/Applications.tsx ===
import React, { useEffect, useState, useMemo } from "react";
import { sdk } from "../lib/sdk";
import { motion, AnimatePresence } from "framer-motion";
import { 
  Briefcase as BriefcaseIcon, 
  Clock as ClockIcon,
  CheckCircle as CheckCircleIcon, 
  XCircle as XCircleIcon,
  Calendar as CalendarIcon,
  Star as StarIcon,
  ExternalLink as ExternalLinkIcon
} from "lucide-react";

type ApplicationStatus = "SAVED" | "DRAFTED" | "APPLIED" | "INTERVIEW" | "OFFER" | "REJECTED";

const StatusPill: React.FC<{ status: ApplicationStatus }> = ({ status }) => {
  const map: Record<ApplicationStatus, string> = {
    SAVED: "bg-gray-100 text-gray-800",
    DRAFTED: "bg-blue-100 text-blue-800",
    APPLIED: "bg-indigo-100 text-indigo-800",
    INTERVIEW: "bg-yellow-100 text-yellow-800",
    OFFER: "bg-emerald-100 text-emerald-800",
    REJECTED: "bg-red-100 text-red-800",
  };
  return (
    <span className={`inline-flex items-center gap-2 px-2.5 py-1 rounded-full text-xs font-medium ${map[status]}`}>
      <span className="w-1.5 h-1.5 rounded-full bg-current/60" />
      {status}
    </span>
  );
};

const ActionButtons: React.FC<{ status: ApplicationStatus; onNext: () => void; onOffer?: () => void; }> = ({ status, onNext, onOffer }) => {
  if (status === "SAVED") return <button className="btn-outline" onClick={onNext}>Mark Applied</button>;
  if (status === "APPLIED") return <button className="btn-outline" onClick={onNext}>Got Interview</button>;
  if (status === "INTERVIEW") return <button className="btn-outline" onClick={onOffer}>Got Offer</button>;
  return null;
};

export default function ApplicationsPage() {
  const [apps, setApps] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const [tab, setTab] = useState<"all" | ApplicationStatus>("all");

  const load = async () => {
    setLoading(true);
    try {
      const data = await sdk.applications.list();
      setApps(data);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => { load(); }, []);

  const visible = useMemo(() => {
    if (tab === "all") return apps;
    return apps.filter((a) => a.status === tab);
  }, [apps, tab]);

  const nextStatus = (s: ApplicationStatus): ApplicationStatus => {
    if (s === "SAVED") return "APPLIED";
    if (s === "APPLIED") return "INTERVIEW";
    return s;
  };

  const handleNext = async (id: string, s: ApplicationStatus) => {
    const ns = nextStatus(s);
    await sdk.applications.setStatus(id, ns);
    await load();
  };

  const handleOffer = async (id: string) => {
    await sdk.applications.setStatus(id, "OFFER");
    await load();
  };

  if (loading) {
    return (
      <div className="page p-6">
        <div className="animate-pulse space-y-4">
          <div className="h-8 w-64 bg-gray-200 rounded" />
          <div className="grid gap-4">{Array.from({ length: 4 }).map((_,i)=>(<div key={i} className="h-40 bg-gray-200 rounded" />))}</div>
        </div>
      </div>
    );
  }

  return (
    <div className="page p-6">
      <div className="mb-6">
        <h1 className="text-3xl font-bold text-gray-900">My Applications</h1>
        <p className="text-gray-600">Track progress and keep momentum</p>
      </div>

      <div className="tabs mb-6">
        {["all","SAVED","APPLIED","INTERVIEW","OFFER","REJECTED"].map((t) => (
          <button key={t} className={`tab ${tab===t ? "active" : ""}`} onClick={() => setTab(t as any)}>{t}</button>
        ))}
      </div>

      <AnimatePresence>
        {visible.length ? (
          <div className="grid gap-4">
            {visible.map((a) => (
              <motion.div
                key={a.id}
                initial={{ opacity: 0, y: 12 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -8 }}
                className="card"
              >
                <div className="flex items-start justify-between">
                  <div>
                    <div className="flex items-center gap-2">
                      <h3 className="text-lg font-semibold text-gray-900">{a.job?.title ?? "Job"}</h3>
                      <StatusPill status={a.status} />
                    </div>
                    <p className="text-gray-600">{a.job?.company ?? "Company"}</p>
                    <div className="mt-2 text-sm text-gray-500 flex gap-4">
                      <span className="inline-flex items-center gap-1"><ClockIcon size={14}/>Applied {new Date(a.createdAt).toLocaleDateString()}</span>
                      {a.interviewDate && <span className="inline-flex items-center gap-1 text-yellow-700"><CalendarIcon size={14}/>Interview {new Date(a.interviewDate).toLocaleDateString()}</span>}
                      {typeof a.fitScore === "number" && <span className="inline-flex items-center gap-1"><StarIcon size={14}/>{a.fitScore}% match</span>}
                    </div>
                  </div>
                  <div className="flex flex-col items-end gap-2">
                    <ActionButtons 
                      status={a.status} 
                      onNext={() => handleNext(a.id, a.status)} 
                      onOffer={() => handleOffer(a.id)} 
                    />
                    {a.job?.externalUrl && (
                      <a className="btn-ghost text-sm inline-flex items-center gap-1" href={a.job.externalUrl} target="_blank" rel="noreferrer">
                        <ExternalLinkIcon size={14}/> View Job
                      </a>
                    )}
                  </div>
                </div>
                {a.notes && <p className="mt-3 text-sm text-gray-700 bg-gray-50 p-3 rounded">{a.notes}</p>}
              </motion.div>
            ))}
          </div>
        ) : (
          <div className="empty text-center py-16">
            <BriefcaseIcon className="mx-auto mb-3 text-gray-300" />
            <h3 className="text-lg font-semibold text-gray-700">No applications here yet</h3>
            <p className="text-gray-500">Apply to roles and track them all in one place.</p>
          </div>
        )}
      </AnimatePresence>

      <style>{`
        .page { min-height: 100vh; }
        .card { background: rgba(255,255,255,0.9); border: 1px solid rgba(0,0,0,0.06); border-radius: 14px; padding: 16px; backdrop-filter: blur(6px); }
        .tabs { display: flex; gap: 8px; }
        .tab { padding: 8px 12px; border-radius: 999px; border: 1px solid rgba(0,0,0,0.08); background: white; font-size: 12px; }
        .tab.active { background: #eef2ff; color: #3730a3; border-color: #c7d2fe; }
        .btn-outline { padding: 6px 10px; border: 1px solid rgba(0,0,0,0.12); border-radius: 10px; background: white; font-size: 12px; }
        .btn-ghost { color: #4338ca; }
      `}</style>
    </div>
  );
}

=== path: apps/web/src/pages/README-Applications.md ===
# Applications Page (Bundle 13)
- Lists and manages applications for the authenticated user.
- Status flow buttons for quick updates (Saved â†’ Applied â†’ Interview â†’ Offer).
- Pulls data from API at `/applications`.
- Replace the token getter in `apps/web/src/lib/sdk.ts` with your auth integration.

=== path: packages/api/README-Applications.md ===
# Applications API (Bundle 13)
Routes mounted at `/applications`:
- `GET /` â€” list applications for current user
- `GET /:id` â€” get one application
- `POST /` â€” create (idempotent on user+job)
- `PATCH /:id` â€” update fields (notes, coverLetter, interviewDate, etc.)
- `POST /:id/status` â€” set status only

Prisma:
- Add models from `schema-partial.application.prisma` to your main schema.
- Then run: `pnpm prisma migrate dev --name add_applications` (or npm/yarn equivalent).

Security:
- Requires auth middleware to set `req.user.id`.
- All operations are scoped to the requesting user.

Next steps (future bundles):
- AI resume tailoring & keyword gap analysis.
- Calendar integration for interviews.
- Notifications.
- Attachments (portfolio, transcripts).
