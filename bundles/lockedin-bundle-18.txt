# LockedIn — Bundle 18: Notifications Center (real‑time, email digests, privacy-aware)

This bundle wires a full notifications system that the rest of the app can publish into:
- Relational schema + indexes
- Type-safe service & REST routes (Express + Prisma)
- Event bus integration & Socket gateway fanout
- Youth‑safety aware filtering (no unverified contacts to minors)
- Web client store + React UI (bell, panel, page)
- Email templates & daily/weekly digests (via SMTP or any provider)
- Tests and integration notes

> No secrets committed. Add env keys to `.env` using the example at the end.  
> Filenames are shown as headers; copy them into your repo preserving paths.

---

## backend/prisma/schema.prisma (append)

```prisma
// ---------- Notifications ----------
enum NotificationType {
  CONNECTION_REQUEST
  CONNECTION_ACCEPT
  MESSAGE
  NEW_POST
  NEW_COMMENT
  POST_LIKE
  JOB_MATCH
  APPLICATION_UPDATE
  INTERVIEW_SCHEDULED
  OFFER
  SAFETY_ALERT
  SYSTEM
}

model Notification {
  id           String            @id @default(cuid())
  userId       String
  actorId      String?
  type         NotificationType
  entityType   String?
  entityId     String?
  title        String
  body         String?
  link         String?
  read         Boolean           @default(false)
  archived     Boolean           @default(false)
  createdAt    DateTime          @default(now())

  // Relations
  user         User              @relation(fields: [userId], references: [id])
  actor        User?             @relation("NotificationActor", fields: [actorId], references: [id])

  @@index([userId, read, createdAt])
  @@index([userId, archived, createdAt])
}
```

> Run migration after adding: `pnpm prisma migrate dev -n "notifications"`

---

## backend/src/modules/notifications/types.ts

```ts
export type NewNotificationPayload = {
  userId: string;            // recipient
  actorId?: string;          // who triggered it
  type:
    | "CONNECTION_REQUEST"
    | "CONNECTION_ACCEPT"
    | "MESSAGE"
    | "NEW_POST"
    | "NEW_COMMENT"
    | "POST_LIKE"
    | "JOB_MATCH"
    | "APPLICATION_UPDATE"
    | "INTERVIEW_SCHEDULED"
    | "OFFER"
    | "SAFETY_ALERT"
    | "SYSTEM";
  entity?: { type?: string; id?: string };
  title: string;
  body?: string;
  link?: string;             // in-app deep link
};
```

---

## backend/src/modules/notifications/notification.service.ts

```ts
import { PrismaClient, NotificationType } from "@prisma/client";
import type { NewNotificationPayload } from "./types";
import { publishSocketEvent } from "../../realtime/socket-pub";
import { isMinorAndRestricted } from "../../trust/safety";
import { getUserById, minimalUser } from "../users/user.service";

const prisma = new PrismaClient();

export async function createNotification(input: NewNotificationPayload) {
  // Safety: prevent unwanted inbound contact to minors from unverified actors.
  if (await isMinorAndRestricted(input.userId, input.actorId, input.type)) {
    // Downgrade to a system safety message or drop depending on policy
    return prisma.notification.create({
      data: {
        userId: input.userId,
        actorId: input.actorId ?? null,
        type: NotificationType.SAFETY_ALERT,
        title: "Safety protection enabled",
        body: "We blocked an unverified contact attempt in youth-safe mode.",
        link: "/safety",
      },
    });
  }

  const n = await prisma.notification.create({
    data: {
      userId: input.userId,
      actorId: input.actorId ?? null,
      type: input.type as NotificationType,
      entityType: input.entity?.type,
      entityId: input.entity?.id,
      title: input.title,
      body: input.body,
      link: input.link,
    },
    include: { actor: true },
  });

  // Fan out to sockets (do not leak PII)
  await publishSocketEvent(input.userId, "notification:new", {
    id: n.id,
    type: n.type,
    title: n.title,
    body: n.body,
    link: n.link,
    createdAt: n.createdAt,
    actor: n.actor ? minimalUser(n.actor) : undefined,
  });

  return n;
}

export async function listNotifications(userId: string, opts?: { cursor?: string; take?: number; unreadOnly?: boolean; }) {
  const take = Math.min(Math.max(opts?.take ?? 20, 1), 100);
  const where = { userId, archived: false, ...(opts?.unreadOnly ? { read: false } : {}) };

  const rows = await prisma.notification.findMany({
    where,
    take,
    ...(opts?.cursor ? { skip: 1, cursor: { id: opts.cursor } } : {}),
    orderBy: { createdAt: "desc" },
  });

  const nextCursor = rows.length === take ? rows[rows.length - 1].id : undefined;
  return { items: rows, nextCursor };
}

export async function markRead(userId: string, ids: string[]) {
  return prisma.notification.updateMany({
    where: { id: { in: ids }, userId },
    data: { read: true },
  });
}

export async function markAllRead(userId: string) {
  return prisma.notification.updateMany({
    where: { userId, read: false, archived: false },
    data: { read: true },
  });
}

export async function archive(userId: string, ids: string[]) {
  return prisma.notification.updateMany({
    where: { id: { in: ids }, userId },
    data: { archived: true },
  });
}

// Convenience publishers other modules can call
export const notify = {
  connectionRequest: (to: string, from: string) =>
    createNotification({
      userId: to,
      actorId: from,
      type: "CONNECTION_REQUEST",
      title: "New connection request",
      body: "Someone wants to connect with you.",
      link: "/network/requests",
    }),

  applicationUpdate: (to: string, title: string, body?: string, link?: string) =>
    createNotification({ userId: to, type: "APPLICATION_UPDATE", title, body, link }),

  jobMatch: (to: string, jobId: string, title: string) =>
    createNotification({
      userId: to,
      type: "JOB_MATCH",
      title,
      body: "A new opportunity matches your profile.",
      entity: { type: "JOB", id: jobId },
      link: `/jobs/${jobId}`,
    }),
};
```

---

## backend/src/modules/notifications/notification.router.ts

```ts
import { Router } from "express";
import { requireAuth } from "../../auth/requireAuth";
import { archive, listNotifications, markAllRead, markRead } from "./notification.service";

export const notificationRouter = Router();

// GET /api/notifications?cursor=...&take=20&unreadOnly=1
notificationRouter.get("/", requireAuth, async (req, res) => {
  const userId = req.auth!.userId;
  const { cursor, take, unreadOnly } = req.query as any;
  const result = await listNotifications(userId, {
    cursor,
    take: take ? parseInt(take, 10) : undefined,
    unreadOnly: !!unreadOnly,
  });
  res.json(result);
});

// PATCH /api/notifications/read
notificationRouter.patch("/read", requireAuth, async (req, res) => {
  const userId = req.auth!.userId;
  const { ids } = req.body as { ids: string[] };
  await markRead(userId, ids);
  res.json({ ok: true });
});

// PATCH /api/notifications/read-all
notificationRouter.patch("/read-all", requireAuth, async (req, res) => {
  const userId = req.auth!.userId;
  await markAllRead(userId);
  res.json({ ok: true });
});

// PATCH /api/notifications/archive
notificationRouter.patch("/archive", requireAuth, async (req, res) => {
  const userId = req.auth!.userId;
  const { ids } = req.body as { ids: string[] };
  await archive(userId, ids);
  res.json({ ok: true });
});
```

> Mount in `app.ts`: `app.use("/api/notifications", notificationRouter);`

---

## backend/src/realtime/socket-pub.ts (publisher helper)

```ts
import { io } from "./socket"; // your initialized Socket.IO server

export async function publishSocketEvent(userId: string, event: string, payload: any) {
  // Namespaced to user room; server should join sockets into room `user:${id}` at auth
  io.to(`user:${userId}`).emit(event, payload);
}
```

---

## backend/src/trust/safety.ts (youth-safety check used by notifications)

```ts
import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();

export async function isMinorAndRestricted(recipientId: string, actorId?: string, type?: string) {
  if (!actorId) return false;
  const [rec, actor] = await Promise.all([
    prisma.user.findUnique({ where: { id: recipientId }, select: { ageMode: true } }),
    prisma.user.findUnique({ where: { id: actorId }, select: { isEmployerVerified: true } }),
  ]);
  // Block direct MESSAGE and CONNECTION_REQUEST to minors from unverified actors
  if (rec?.ageMode === "YOUTH" && ["MESSAGE", "CONNECTION_REQUEST"].includes(type || "") && !actor?.isEmployerVerified) {
    return true;
  }
  return false;
}

export const minimalUser = (u: any) => ({ id: u.id, fullName: u.fullName, avatarUrl: u.avatarUrl });
```

---

## backend/src/jobs/digests.ts (daily/weekly email digests)

```ts
import { PrismaClient } from "@prisma/client";
import { sendMail } from "../mail/mailer";
import { renderDigest } from "../mail/templates/digest";

const prisma = new PrismaClient();

export async function sendDailyDigests() {
  const users = await prisma.user.findMany({ where: { emailNotifications: true } });
  for (const u of users) {
    const since = new Date(Date.now() - 24 * 3600 * 1000);
    const items = await prisma.notification.findMany({
      where: { userId: u.id, createdAt: { gte: since }, archived: false },
      orderBy: { createdAt: "desc" },
      take: 20,
    });
    if (items.length === 0) continue;
    const html = renderDigest(u, items);
    await sendMail({
      to: u.email,
      subject: "Your daily activity summary",
      html,
    });
  }
}
```

---

## backend/src/mail/mailer.ts (provider‑agnostic sender)

```ts
import nodemailer from "nodemailer";

const smtpUrl = process.env.SMTP_URL; // e.g. smtp://user:pass@smtp.example.com:587

if (!smtpUrl) {
  console.warn("[mail] SMTP_URL not set. Emails will be no‑op in dev.");
}

export async function sendMail(opts: { to: string; subject: string; html: string; from?: string }) {
  if (!smtpUrl) return;
  const transporter = nodemailer.createTransport(smtpUrl);
  const from = opts.from || process.env.MAIL_FROM || "LockedIn <no-reply@lockedin.example>";
  await transporter.sendMail({ from, ...opts });
}
```

---

## backend/src/mail/templates/digest.ts

```ts
import { Notification } from "@prisma/client";

export function renderDigest(user: any, items: Notification[]) {
  const rows = items.map(i => `
    <tr>
      <td style="padding:8px 0;font:14px/20px system-ui">
        <strong>${escapeHtml(i.title)}</strong><br/>
        <span style="color:#555">${escapeHtml(i.body || "")}</span><br/>
        <small style="color:#888">${new Date(i.createdAt).toLocaleString()}</small>
      </td>
    </tr>`).join("");

  return `
  <table style="max-width:600px;margin:0 auto">
    <tr><td style="font:18px/24px system-ui;padding:16px 0">Hi ${escapeHtml(user.fullName || "there")}, here’s your daily activity.</td></tr>
    ${rows}
    <tr><td style="padding:16px 0"><a href="${process.env.APP_URL || "https://app.lockedin.example"}/notifications">Open notifications</a></td></tr>
  </table>`;
}

function escapeHtml(s: string) {
  return s.replace(/[&<>"']/g, (c) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[c] as string));
}
```

---

## web/src/stores/notifications.ts (Zustand store)

```ts
import create from "zustand";
import { persist } from "zustand/middleware";
import { api } from "@/sdk/api";

export type NotificationItem = {
  id: string;
  type: string;
  title: string;
  body?: string;
  link?: string;
  createdAt: string;
  read: boolean;
  actor?: { id: string; fullName: string; avatarUrl?: string };
};

type State = {
  items: NotificationItem[];
  unread: number;
  cursor?: string;
  loading: boolean;
  fetch: (opts?: { unreadOnly?: boolean }) => Promise<void>;
  markRead: (ids: string[]) => Promise<void>;
  markAllRead: () => Promise<void>;
  receive: (n: NotificationItem) => void;
};

export const useNotifications = create<State>()(
  persist(
    (set, get) => ({
      items: [],
      unread: 0,
      loading: false,
      async fetch(opts) {
        set({ loading: true });
        const res = await api.get("/notifications", { params: { take: 20, unreadOnly: opts?.unreadOnly ? 1 : undefined } });
        set({
          items: res.data.items as NotificationItem[],
          cursor: res.data.nextCursor,
          unread: (res.data.items as NotificationItem[]).filter(i => !i.read).length,
          loading: false,
        });
      },
      async markRead(ids) {
        await api.patch("/notifications/read", { ids });
        set(state => ({
          items: state.items.map(i => (ids.includes(i.id) ? { ...i, read: true } : i)),
          unread: Math.max(0, state.unread - ids.length),
        }));
      },
      async markAllRead() {
        await api.patch("/notifications/read-all");
        set(state => ({
          items: state.items.map(i => ({ ...i, read: true })),
          unread: 0,
        }));
      },
      receive(n) {
        set(state => ({ items: [n, ...state.items], unread: state.unread + 1 }));
      },
    }),
    { name: "notifications" }
  )
);
```

---

## web/src/components/notifications/NotificationsBell.tsx

```tsx
import React, { useEffect } from "react";
import { BellIcon, CheckCheckIcon } from "lucide-react";
import { useNotifications } from "@/stores/notifications";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Button } from "@/components/ui/button";
import { socket } from "@/sdk/socket";
import { Link } from "react-router-dom";

export function NotificationsBell() {
  const { unread, items, fetch, markAllRead, receive } = useNotifications();

  useEffect(() => {
    fetch();
    socket.on("notification:new", receive);
    return () => {
      socket.off("notification:new", receive);
    };
  }, []);

  return (
    <Popover>
      <PopoverTrigger asChild>
        <button className="relative p-2 rounded-xl hover:bg-indigo-50 transition">
          <BellIcon className="w-5 h-5 text-indigo-700" />
          {unread > 0 && (
            <span className="absolute -top-0.5 -right-0.5 bg-rose-500 text-white text-[10px] font-semibold rounded-full px-1">
              {unread > 9 ? "9+" : unread}
            </span>
          )}
        </button>
      </PopoverTrigger>
      <PopoverContent className="w-96 p-0">
        <div className="flex items-center justify-between px-4 py-3 border-b">
          <div className="font-semibold">Notifications</div>
          <Button variant="ghost" size="sm" onClick={() => markAllRead()} disabled={!unread}>
            <CheckCheckIcon className="w-4 h-4 mr-1" /> Mark all read
          </Button>
        </div>
        <ScrollArea className="max-h-96">
          {items.length === 0 ? (
            <div className="p-6 text-sm text-gray-500">You’re all caught up.</div>
          ) : (
            <ul className="divide-y">
              {items.slice(0, 12).map((n) => (
                <li key={n.id} className={`px-4 py-3 ${!n.read ? "bg-indigo-50/40" : ""}`}>
                  <Link to={n.link || "/notifications"} className="block">
                    <div className="text-sm font-medium text-gray-900">{n.title}</div>
                    {n.body && <div className="text-xs text-gray-600 mt-0.5">{n.body}</div>}
                    <div className="text-[10px] text-gray-400 mt-1">{new Date(n.createdAt).toLocaleString()}</div>
                  </Link>
                </li>
              ))}
            </ul>
          )}
          <div className="p-3 border-t text-center">
            <Link to="/notifications" className="text-indigo-600 text-sm font-medium">View all</Link>
          </div>
        </ScrollArea>
      </PopoverContent>
    </Popover>
  );
}
```

---

## web/src/pages/NotificationsPage.tsx

```tsx
import React, { useEffect } from "react";
import { useNotifications } from "@/stores/notifications";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { CheckIcon, TrashIcon } from "lucide-react";

export default function NotificationsPage() {
  const { items, fetch, markRead, markAllRead } = useNotifications();

  useEffect(() => { fetch(); }, []);

  const unreadIds = items.filter(i => !i.read).map(i => i.id);

  return (
    <div className="p-6 md:p-8 max-w-4xl mx-auto">
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-2xl md:text-3xl font-bold text-gray-900">All Notifications</h1>
        <div className="flex gap-2">
          <Button variant="outline" onClick={() => markAllRead()} disabled={unreadIds.length === 0}>
            <CheckIcon className="w-4 h-4 mr-1" /> Mark all read
          </Button>
        </div>
      </div>

      <div className="space-y-4">
        {items.map(n => (
          <Card key={n.id} className={!n.read ? "border-indigo-200/70 bg-indigo-50/30" : ""}>
            <CardHeader className="pb-2">
              <CardTitle className="text-base">{n.title}</CardTitle>
            </CardHeader>
            <CardContent className="pt-0 text-sm text-gray-700">
              {n.body && <p className="mb-2">{n.body}</p>}
              <div className="flex items-center justify-between text-xs text-gray-500">
                <span>{new Date(n.createdAt).toLocaleString()}</span>
                {!n.read && (
                  <Button size="sm" variant="ghost" onClick={() => markRead([n.id])}>
                    <CheckIcon className="w-4 h-4 mr-1" /> Mark read
                  </Button>
                )}
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
}
```

---

## web/src/sdk/socket.ts (client socket glue)

```ts
import { io, Socket } from "socket.io-client";
import { getAuthToken } from "./auth";

export const socket: Socket = io(import.meta.env.VITE_SOCKET_URL || "", {
  autoConnect: true,
  transports: ["websocket"],
  extraHeaders: async () => ({
    Authorization: `Bearer ${getAuthToken() || ""}`,
  }),
});
```

---

## backend/src/tests/notifications.test.ts

```ts
import { createNotification, listNotifications, markAllRead } from "../modules/notifications/notification.service";

describe("notifications", () => {
  const alice = "user_alice";
  const bob = "user_bob";

  it("creates and lists notifications", async () => {
    await createNotification({
      userId: alice,
      actorId: bob,
      type: "CONNECTION_REQUEST",
      title: "New connection request",
      body: "Bob wants to connect",
      link: "/network/requests",
    });

    const list = await listNotifications(alice, { take: 10 });
    expect(list.items.length).toBeGreaterThan(0);
    expect(list.items[0].title).toMatch(/connection/i);
  });

  it("marks all as read", async () => {
    await markAllRead(alice);
    const list = await listNotifications(alice, { take: 10 });
    expect(list.items.every(i => i.read)).toBe(true);
  });
});
```

---

## backend/src/modules/notifications/README.md

```md
# Notifications Module

### Features
- Persisted notifications with read/archive state
- Safety-aware filtering for minors
- Socket fanout: room `user:{id}` gets `notification:new`
- REST: list, mark read, mark all read, archive
- Email digests (daily/weekly) via SMTP

### Integrations
Other modules publish via `notify.*` helpers:
- `notify.connectionRequest(toUserId, actorUserId)`
- `notify.applicationUpdate(toUserId, title, body?, link?)`
- `notify.jobMatch(toUserId, jobId, jobTitle)`

### Setup
1. Add schema, run `prisma migrate`
2. Mount router: `app.use("/api/notifications", notificationRouter)`
3. Ensure socket auth joins `socket.join("user:" + user.id)`
4. Configure SMTP: `SMTP_URL` and `MAIL_FROM`
5. Schedule daily digests (e.g., node-cron) to call `sendDailyDigests()`
```

---

## .env.example (append)

```env
# Realtime & App
VITE_SOCKET_URL=http://localhost:3001
APP_URL=http://localhost:5173

# Mail
SMTP_URL=smtp://username:password@smtp.yourhost.com:587
MAIL_FROM="LockedIn <no-reply@lockedin.example>"
```

---

## Changelog

- feat(notifications): DB schema + service + REST
- feat(realtime): user-room fanout helper
- feat(web): bell popover + page + persisted store
- feat(email): digest template + sender
- feat(safety): policy guard for minors
- test: basic service flow

---

### Done. Next suggested bundle
**Bundle 19 — Recruiter Tools (company pages, pipelines, bulk messaging, screening forms)**
