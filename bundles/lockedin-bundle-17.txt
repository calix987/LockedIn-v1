
LOCKEDIN — BUNDLE 17
Direct Messaging (DM), Threads, Safety Filters, and Reporting
=============================================================

Scope
-----
This bundle implements secure, real‑time messaging with:
- Threads, participants, read receipts, typing indicators
- Attachments (metadata + pluggable storage provider)
- Youth‑safe DM policies (minors can only be contacted by verified employers; meeting‑up and PII exchange are blocked)
- On‑device redaction for under‑18s; server‑side enforcement always wins
- Message‑level reporting & moderation queue
- Web client components (sidebar, chat window, input, safety banners)
- API Client SDK
- Seed data + minimal tests

IMPORTANT
---------
- No secrets are included. All configs come from environment variables.
- This bundle assumes previous bundles set up: Prisma, Express, auth middleware, WS gateway factory, and user/role entities.
- Storage for binary attachments is abstracted behind an interface (use local dev storage by default).

Directory Layout
----------------
apps/
  api/
    src/
      messaging/
        contracts/
          Message.ts
          Thread.ts
          Moderation.ts
        prisma/
          schema.extend.messaging.prisma
        http/
          messaging.router.ts
          messaging.controller.ts
          messaging.service.ts
          messaging.moderation.ts
          messaging.policies.ts
          attachment.storage.ts
        ws/
          messaging.ws.ts
      tests/
        messaging.moderation.spec.ts
        messaging.policies.spec.ts
  web/
    src/
      lib/api/messaging.ts
      components/messaging/ChatSidebar.tsx
      components/messaging/ChatWindow.tsx
      components/messaging/MessageInput.tsx
      components/messaging/SafetyBanner.tsx
      pages/MessagesPage.tsx

shared/
  types/
    messaging.ts

env/
  api.example.env

README-17.md

------------------------------------------------------------
FILE: shared/types/messaging.ts
------------------------------------------------------------
export type ParticipantRole = 'APPLICANT' | 'RECRUITER' | 'EMPLOYER_ADMIN' | 'COACH';

export interface ThreadSummary {
  id: string;
  createdAt: string;
  updatedAt: string;
  title?: string;
  lastMessagePreview?: string;
  unreadCount: number;
  participantIds: string[];
  isYouthSafe: boolean; // true if any participant is a minor
}

export interface Message {
  id: string;
  threadId: string;
  authorId: string;
  text?: string;
  redactedText?: string;   // populated when redaction occurred for viewer
  attachments?: Attachment[];
  createdAt: string;
  updatedAt: string;
  edited: boolean;
  system: boolean;
  moderation?: ModerationFlags;
}

export interface Attachment {
  id: string;
  kind: 'IMAGE' | 'PDF' | 'DOC' | 'OTHER';
  filename: string;
  mimeType: string;
  size: number;
  url: string; // pre-signed or proxied URL
}

export interface ModerationFlags {
  containsPII?: boolean;
  containsExternalLink?: boolean;
  containsMeetupIntent?: boolean;
  containsProfanity?: boolean;
  policyBlocked?: boolean;
  redacted?: boolean;
  reason?: string;
}

export interface CreateThreadDTO {
  participantIds: string[]; // includes the caller; 2+
  title?: string;
  initialMessage?: string;
}

export interface SendMessageDTO {
  threadId: string;
  text?: string;
  attachmentIds?: string[];
  clientTempId?: string;
}

export interface TypingEvent {
  threadId: string;
  userId: string;
  isTyping: boolean;
}

export interface ReadReceiptEvent {
  threadId: string;
  userId: string;
  messageId: string;
  readAt: string;
}

------------------------------------------------------------
FILE: apps/api/src/messaging/prisma/schema.extend.messaging.prisma
------------------------------------------------------------
/**
 * Prisma schema extension for messaging.
 * Merge with base schema in your Prisma build step.
 */

model Thread {
  id            String           @id @default(cuid())
  title         String?
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  participants  ThreadParticipant[]
  messages      Message[]
  lastMessageAt DateTime?
  youthSafe     Boolean          @default(false) // true if any participant is a minor
  // For search
  searchable    String?          @db.Text
  @@index([lastMessageAt])
}

model ThreadParticipant {
  id         String   @id @default(cuid())
  threadId   String
  userId     String
  role       String   // 'APPLICANT' | 'RECRUITER' | 'EMPLOYER_ADMIN' | 'COACH'
  joinedAt   DateTime @default(now())
  // unread tracking
  lastReadMessageId String?
  Thread     Thread  @relation(fields: [threadId], references: [id], onDelete: Cascade)
  @@unique([threadId, userId])
}

model Message {
  id           String   @id @default(cuid())
  threadId     String
  authorId     String
  text         String?  @db.Text
  redactedText String?  @db.Text  // server-side redaction text stored for audit
  system       Boolean  @default(false)
  edited       Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  moderation   Json?
  Thread       Thread   @relation(fields: [threadId], references: [id], onDelete: Cascade)
  attachments  Attachment[]
  @@index([threadId, createdAt])
}

model Attachment {
  id        String   @id @default(cuid())
  kind      String
  filename  String
  mimeType  String
  size      Int
  url       String    // storage URL or key (server will sign/proxy)
  messageId String?
  message   Message?  @relation(fields: [messageId], references: [id], onDelete: SetNull)
  createdAt DateTime  @default(now())
}

model MessageReport {
  id          String   @id @default(cuid())
  messageId   String
  reporterId  String
  reason      String
  details     String?
  createdAt   DateTime @default(now())
}

------------------------------------------------------------
FILE: apps/api/src/messaging/http/messaging.policies.ts
------------------------------------------------------------
import { Request } from 'express';

type Role = 'APPLICANT' | 'RECRUITER' | 'EMPLOYER_ADMIN' | 'COACH';

export interface SafetyContext {
  isMinor: boolean;
  isEmployerVerified: boolean;
  viewerId: string;
}

export const MessagingPolicies = {
  canCreateThread(participants: Array<{ id: string; isMinor: boolean; isEmployerVerified: boolean; role: Role }>): { ok: boolean; reason?: string } {
    const hasMinor = participants.some(p => p.isMinor);
    if (!hasMinor) return { ok: true };
    // If there is a minor, ALL non-minor business participants must be verified employers or coaches.
    const nonMinorBusiness = participants.filter(p => !p.isMinor && (p.role === 'RECRUITER' || p.role === 'EMPLOYER_ADMIN'));
    const anyUnverified = nonMinorBusiness.some(p => !p.isEmployerVerified);
    if (anyUnverified) {
      return { ok: false, reason: 'Minors can only be contacted by verified employers.' };
    }
    return { ok: true };
  },

  canSendMessage(ctx: SafetyContext): { ok: boolean; reason?: string } {
    // Minors may send messages, but policy enforcement will redact PII/meet-up content automatically.
    // Non-verified employers cannot DM minors at all.
    if (ctx.isMinor && !ctx.isEmployerVerified) {
      return { ok: false, reason: 'Only verified employers can contact youth accounts.' };
    }
    return { ok: true };
  },
};

------------------------------------------------------------
FILE: apps/api/src/messaging/http/messaging.moderation.ts
------------------------------------------------------------
/**
 * Lightweight sync moderation utilities.
 * For production, plug into your async moderation pipeline (OpenAI, AWS Comprehend, Perspective, etc.).
 */
const EMAIL = /\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/i;
const PHONE = /(\+?\d[\s\-\.]?)?(\(?\d{3}\)?[\s\-\.]?)?\d{3}[\s\-\.]?\d{4}\b/;
const URL = /\b(https?:\/\/|www\.)[^\s/$.?#].[^\s]*\b/i;
const MEETUP = /\b(meet|meet\s*up|in person|coffee|mall|park|address|come to|my place|your place)\b/i;
const PROFANITY = /\b(fuck|shit|bitch|asshole|dumbass|cunt)\b/i;

export interface ModerationResult {
  redactedText?: string;
  flags: {
    containsPII?: boolean;
    containsExternalLink?: boolean;
    containsMeetupIntent?: boolean;
    containsProfanity?: boolean;
    policyBlocked?: boolean;
    redacted?: boolean;
    reason?: string;
  };
}

export function moderateText(input: string, isMinorThread: boolean): ModerationResult {
  const flags: ModerationResult['flags'] = {};

  const matchesEmail = EMAIL.test(input);
  const matchesPhone = PHONE.test(input);
  const matchesUrl = URL.test(input);
  const matchesMeetup = MEETUP.test(input);
  const matchesProfanity = PROFANITY.test(input);

  if (matchesEmail || matchesPhone) flags.containsPII = true;
  if (matchesUrl) flags.containsExternalLink = true;
  if (matchesMeetup) flags.containsMeetupIntent = true;
  if (matchesProfanity) flags.containsProfanity = true;

  // Redaction rules for minors (viewer & thread safety)
  let redactedText = input;
  if (isMinorThread) {
    if (flags.containsPII) {
      redactedText = redactedText.replace(EMAIL, '[redacted-email]').replace(PHONE, '[redacted-phone]');
    }
    if (flags.containsExternalLink) {
      redactedText = redactedText.replace(URL, '[redacted-link]');
    }
    if (flags.containsMeetupIntent) {
      redactedText = redactedText.replace(MEETUP, '[redacted-meetup]');
    }
  }

  const redacted = redactedText !== input;
  return { redactedText: redacted ? redactedText : undefined, flags: { ...flags, redacted } };
}

------------------------------------------------------------
FILE: apps/api/src/messaging/http/attachment.storage.ts
------------------------------------------------------------
/**
 * Attachment storage abstraction.
 * Default: local dev storage (NOT for production).
 * Replace with S3/GCS/Azure by implementing the same interface.
 */
import path from 'path';
import fs from 'fs';

export interface UploadedAttachment {
  id: string;
  url: string;
  size: number;
  mimeType: string;
  filename: string;
  kind: 'IMAGE' | 'PDF' | 'DOC' | 'OTHER';
}

export interface AttachmentStorage {
  save(buffer: Buffer, filename: string, mimeType: string): Promise<UploadedAttachment>;
  getPublicUrl(key: string): Promise<string>;
}

export class LocalDevStorage implements AttachmentStorage {
  constructor(private baseDir = path.join(process.cwd(), 'var', 'attachments')) {}
  async save(buffer: Buffer, filename: string, mimeType: string) {
    fs.mkdirSync(this.baseDir, { recursive: true });
    const id = `${Date.now()}-${Math.random().toString(36).slice(2)}`;
    const key = path.join(this.baseDir, id + '-' + filename);
    fs.writeFileSync(key, buffer);
    return {
      id,
      url: `/attachments/${path.basename(key)}`,
      size: buffer.length,
      mimeType,
      filename,
      kind: guessKind(mimeType),
    };
  }
  async getPublicUrl(key: string) {
    return `/attachments/${key}`;
  }
}

function guessKind(mime: string): UploadedAttachment['kind'] {
  if (mime.startsWith('image/')) return 'IMAGE';
  if (mime === 'application/pdf') return 'PDF';
  if (mime.includes('word') || mime.includes('officedocument')) return 'DOC';
  return 'OTHER';
}

------------------------------------------------------------
FILE: apps/api/src/messaging/http/messaging.service.ts
------------------------------------------------------------
import { PrismaClient } from '@prisma/client';
import { moderateText } from './messaging.moderation';
import { MessagingPolicies } from './messaging.policies';

const prisma = new PrismaClient();

export const MessagingService = {
  async createThread(currentUser: any, dto: { participantIds: string[]; title?: string; initialMessage?: string }) {
    if (!dto.participantIds.includes(currentUser.id)) {
      dto.participantIds.push(currentUser.id);
    }
    const uniq = Array.from(new Set(dto.participantIds));
    if (uniq.length < 2) throw new Error('A thread needs 2+ participants');

    const users = await prisma.user.findMany({ where: { id: { in: uniq } }, select: { id: true, isMinor: true, isEmployerVerified: true, role: true } });
    const pol = MessagingPolicies.canCreateThread(users as any);
    if (!pol.ok) throw new Error(pol.reason || 'Thread creation not allowed');

    const youthSafe = users.some(u => (u as any).isMinor === true);
    const thread = await prisma.thread.create({
      data: {
        title: dto.title,
        youthSafe,
        participants: { create: users.map(u => ({ userId: u.id, role: (u as any).role || 'APPLICANT' })) },
      },
    });

    if (dto.initialMessage) {
      await MessagingService.sendMessage(currentUser, { threadId: thread.id, text: dto.initialMessage });
    }

    return thread;
  },

  async listThreads(currentUserId: string) {
    const parts = await prisma.threadParticipant.findMany({
      where: { userId: currentUserId },
      include: { Thread: true },
      orderBy: { Thread: { lastMessageAt: 'desc' } },
    });
    const threadIds = parts.map(p => p.threadId);
    const counts = await prisma.message.groupBy({
      by: ['threadId'],
      where: { threadId: { in: threadIds } },
      _max: { createdAt: true },
    });

    return parts.map(p => ({
      id: p.threadId,
      createdAt: p.Thread.createdAt,
      updatedAt: p.Thread.updatedAt,
      title: p.Thread.title || undefined,
      lastMessagePreview: undefined, // can be hydrated by a join if needed
      unreadCount: 0, // compute w/ lastRead
      participantIds: [],
      isYouthSafe: p.Thread.youthSafe,
      lastMessageAt: (counts.find(c => c.threadId === p.threadId)?._max?.createdAt) || p.Thread.updatedAt,
    }));
  },

  async sendMessage(currentUser: any, dto: { threadId: string; text?: string; attachmentIds?: string[] }) {
    const thread = await prisma.thread.findUnique({ where: { id: dto.threadId } });
    if (!thread) throw new Error('Thread not found');

    const participant = await prisma.threadParticipant.findFirst({ where: { threadId: dto.threadId, userId: currentUser.id } });
    if (!participant) throw new Error('Not in this thread');

    const pol = MessagingPolicies.canSendMessage({
      isMinor: currentUser.isMinor,
      isEmployerVerified: currentUser.isEmployerVerified,
      viewerId: currentUser.id,
    });
    if (!pol.ok) throw new Error(pol.reason || 'Not allowed to send');

    let moderation: any = undefined;
    let redactedText: string | undefined;

    if (dto.text && dto.text.trim().length) {
      const mod = moderateText(dto.text, thread.youthSafe);
      moderation = mod.flags;
      redactedText = mod.redactedText;
    }

    const msg = await prisma.message.create({
      data: {
        threadId: dto.threadId,
        authorId: currentUser.id,
        text: dto.text,
        redactedText,
        moderation,
      },
    });

    // Update last message timestamp
    await prisma.thread.update({ where: { id: dto.threadId }, data: { lastMessageAt: new Date() } });

    return msg;
  },

  async reportMessage(currentUserId: string, dto: { messageId: string; reason: string; details?: string }) {
    // Basic duplicate prevention
    const existing = await prisma.messageReport.findFirst({ where: { messageId: dto.messageId, reporterId: currentUserId } });
    if (existing) return existing;
    return prisma.messageReport.create({ data: { ...dto, reporterId: currentUserId } });
  },
};

------------------------------------------------------------
FILE: apps/api/src/messaging/http/messaging.controller.ts
------------------------------------------------------------
import { Router } from 'express';
import { MessagingService } from './messaging.service';
import { requireAuth } from '../../middleware/auth'; // assumed existing
export const messagingController = Router();

// Create thread
messagingController.post('/threads', requireAuth, async (req: any, res) => {
  try {
    const thread = await MessagingService.createThread(req.user, req.body);
    res.json(thread);
  } catch (e: any) {
    res.status(400).json({ error: e.message });
  }
});

// List my threads
messagingController.get('/threads', requireAuth, async (req: any, res) => {
  const data = await MessagingService.listThreads(req.user.id);
  res.json(data);
});

// Send message
messagingController.post('/messages', requireAuth, async (req: any, res) => {
  try {
    const msg = await MessagingService.sendMessage(req.user, req.body);
    res.json(msg);
  } catch (e: any) {
    res.status(400).json({ error: e.message });
  }
});

// Report message
messagingController.post('/messages/:id/report', requireAuth, async (req: any, res) => {
  try {
    const report = await MessagingService.reportMessage(req.user.id, { messageId: req.params.id, reason: req.body.reason, details: req.body.details });
    res.json(report);
  } catch (e: any) {
    res.status(400).json({ error: e.message });
  }
});

------------------------------------------------------------
FILE: apps/api/src/messaging/ws/messaging.ws.ts
------------------------------------------------------------
/**
 * WS/Gateway integration.
 * Assumes you have a socket.io instance available via `createGateway(io)`. Plug in events below.
 */
import type { Server } from 'socket.io';

export function registerMessagingGateway(io: Server) {
  io.on('connection', (socket) => {
    const userId = (socket.handshake.auth as any)?.userId;
    if (!userId) return;

    socket.on('messaging:joinThread', (threadId: string) => {
      socket.join(`thread:${threadId}`);
    });

    socket.on('messaging:typing', (payload: { threadId: string; isTyping: boolean }) => {
      socket.to(`thread:${payload.threadId}`).emit('messaging:typing', { userId, ...payload });
    });

    socket.on('messaging:read', (payload: { threadId: string; messageId: string }) => {
      socket.to(`thread:${payload.threadId}`).emit('messaging:read', { userId, ...payload, readAt: new Date().toISOString() });
    });
  });
}

------------------------------------------------------------
FILE: apps/web/src/lib/api/messaging.ts
------------------------------------------------------------
import { api } from './client'; // assumed
import type { CreateThreadDTO, SendMessageDTO, ThreadSummary, Message } from '../../../../shared/types/messaging';

export const MessagingAPI = {
  createThread(dto: CreateThreadDTO) {
    return api.post('/messaging/threads', dto).then(r => r.data);
  },
  listThreads(): Promise<ThreadSummary[]> {
    return api.get('/messaging/threads').then(r => r.data);
  },
  sendMessage(dto: SendMessageDTO): Promise<Message> {
    return api.post('/messaging/messages', dto).then(r => r.data);
  },
  reportMessage(id: string, reason: string, details?: string) {
    return api.post(`/messaging/messages/${id}/report`, { reason, details }).then(r => r.data);
  },
};

------------------------------------------------------------
FILE: apps/web/src/components/messaging/SafetyBanner.tsx
------------------------------------------------------------
import React from 'react';
import { ShieldCheckIcon, AlertTriangleIcon } from 'lucide-react';

export default function SafetyBanner({ youthSafe }: { youthSafe: boolean }) {
  if (!youthSafe) return null;
  return (
    <div className="mb-3 rounded-lg border border-emerald-200 bg-emerald-50 p-3 text-emerald-900 text-sm flex items-start gap-2">
      <ShieldCheckIcon className="w-4 h-4 mt-0.5" />
      <div>
        <strong>Youth safety is on.</strong> Links, contact info, and meet‑up details are restricted. Keep all communication on the platform.
      </div>
    </div>
  );
}

------------------------------------------------------------
FILE: apps/web/src/components/messaging/MessageInput.tsx
------------------------------------------------------------
import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { PaperclipIcon, SendIcon, AlertCircleIcon } from 'lucide-react';

const EMAIL = /\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/i;
const PHONE = /(\+?\d[\s\-\.]?)?(\(?\d{3}\)?[\s\-\.]?)?\d{3}[\s\-\.]?\d{4}\b/;
const URL = /\b(https?:\/\/|www\.)[^\s/$.?#].[^\s]*\b/i;
const MEETUP = /\b(meet|meet\s*up|in person|coffee|mall|park|address|come to|my place|your place)\b/i;

export default function MessageInput({ onSend, youthSafe }: { onSend: (text: string) => Promise<void>, youthSafe: boolean }) {
  const [text, setText] = useState('');
  const [warning, setWarning] = useState<string | null>(null);
  const [sending, setSending] = useState(false);

  function validate(t: string) {
    if (!youthSafe) return null;
    if (EMAIL.test(t) || PHONE.test(t)) return 'Sharing personal contact info is blocked for youth safety.';
    if (URL.test(t)) return 'Links are restricted in youth‑safe conversations.';
    if (MEETUP.test(t)) return 'Arranging in‑person meetings is not allowed here.';
    return null;
  }

  async function handleSend() {
    const w = validate(text);
    setWarning(w);
    if (w) return;
    setSending(true);
    try {
      await onSend(text);
      setText('');
    } finally {
      setSending(false);
    }
  }

  return (
    <div className="border-t bg-white/70 backdrop-blur px-3 py-2">
      {warning && (
        <div className="mb-2 flex items-center gap-2 text-amber-700 bg-amber-50 border border-amber-200 rounded px-2 py-1 text-xs">
          <AlertCircleIcon className="w-3 h-3" /> {warning}
        </div>
      )}
      <div className="flex items-end gap-2">
        <textarea
          value={text}
          onChange={(e) => setText(e.target.value)}
          placeholder="Write a message…"
          rows={1}
          className="flex-1 resize-none rounded-lg border border-gray-200 bg-white p-2 text-sm shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-200"
        />
        <Button size="sm" variant="outline" className="shrink-0">
          <PaperclipIcon className="w-4 h-4" />
        </Button>
        <Button onClick={handleSend} size="sm" disabled={sending || !text.trim()} className="shrink-0">
          <SendIcon className="w-4 h-4 mr-1" /> Send
        </Button>
      </div>
    </div>
  );
}

------------------------------------------------------------
FILE: apps/web/src/components/messaging/ChatSidebar.tsx
------------------------------------------------------------
import React, { useEffect, useState } from 'react';
import { MessagingAPI } from '@/lib/api/messaging';
import type { ThreadSummary } from '../../../../shared/types/messaging';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';

export default function ChatSidebar({ onSelect, activeId }: { onSelect: (id: string) => void; activeId?: string }) {
  const [threads, setThreads] = useState<ThreadSummary[]>([]);
  const [q, setQ] = useState('');

  useEffect(() => {
    MessagingAPI.listThreads().then(setThreads);
  }, []);

  const filtered = threads.filter(t => (t.title || '').toLowerCase().includes(q.toLowerCase()));

  return (
    <div className="w-full md:w-80 border-r bg-white/70 backdrop-blur">
      <div className="p-3">
        <Input value={q} onChange={e => setQ(e.target.value)} placeholder="Search conversations…" />
      </div>
      <div className="divide-y">
        {filtered.map(t => (
          <button
            key={t.id}
            onClick={() => onSelect(t.id)}
            className={`w-full text-left px-3 py-3 hover:bg-indigo-50 ${activeId === t.id ? 'bg-indigo-50' : ''}`}
          >
            <div className="flex items-center justify-between">
              <div className="font-medium text-gray-900 truncate">{t.title || 'Conversation'}</div>
              {t.isYouthSafe && <Badge className="bg-emerald-100 text-emerald-800">Youth Safe</Badge>}
            </div>
            <div className="text-xs text-gray-500">{t.lastMessagePreview || '…'}</div>
          </button>
        ))}
      </div>
    </div>
  );
}

------------------------------------------------------------
FILE: apps/web/src/components/messaging/ChatWindow.tsx
------------------------------------------------------------
import React, { useState } from 'react';
import SafetyBanner from './SafetyBanner';
import MessageInput from './MessageInput';

type Message = {
  id: string;
  authorId: string;
  text?: string;
  redactedText?: string;
  createdAt: string;
  moderation?: { redacted?: boolean };
};

export default function ChatWindow({ youthSafe, threadId, onSend }: { youthSafe: boolean; threadId: string; onSend: (text: string) => Promise<void> }) {
  const [items, setItems] = useState<Message[]>([]);

  async function handleSend(text: string) {
    const m: Message = {
      id: 'temp-' + Date.now(),
      authorId: 'me',
      text,
      createdAt: new Date().toISOString(),
    };
    setItems(prev => [...prev, m]);
    await onSend(text);
  }

  return (
    <div className="flex-1 flex flex-col">
      <div className="px-4 py-2">
        <SafetyBanner youthSafe={youthSafe} />
      </div>
      <div className="flex-1 overflow-y-auto px-4 py-2 space-y-3">
        {items.map(m => (
          <div key={m.id} className={`max-w-[70%] rounded-lg p-2 text-sm shadow ${m.authorId === 'me' ? 'ml-auto bg-indigo-600 text-white' : 'bg-white border'}`}>
            {m.redactedText || m.text}
          </div>
        ))}
      </div>
      <MessageInput youthSafe={youthSafe} onSend={handleSend} />
    </div>
  );
}

------------------------------------------------------------
FILE: apps/web/src/pages/MessagesPage.tsx
------------------------------------------------------------
import React, { useState } from 'react';
import ChatSidebar from '@/components/messaging/ChatSidebar';
import ChatWindow from '@/components/messaging/ChatWindow';
import { MessagingAPI } from '@/lib/api/messaging';

export default function MessagesPage() {
  const [activeId, setActiveId] = useState<string | undefined>();
  const [youthSafe, setYouthSafe] = useState<boolean>(true); // hydrate from thread summary

  async function send(text: string) {
    if (!activeId) return;
    await MessagingAPI.sendMessage({ threadId: activeId, text });
  }

  return (
    <div className="min-h-[80vh] bg-gradient-to-br from-gray-50 via-white to-blue-50 border rounded-xl overflow-hidden shadow">
      <div className="flex">
        <ChatSidebar activeId={activeId} onSelect={(id) => { setActiveId(id); /* fetch thread meta & setYouthSafe */ }} />
        <ChatWindow youthSafe={youthSafe} threadId={activeId || ''} onSend={send} />
      </div>
    </div>
  );
}

------------------------------------------------------------
FILE: apps/api/src/tests/messaging.moderation.spec.ts
------------------------------------------------------------
import { moderateText } from '../messaging/http/messaging.moderation';

describe('moderateText', () => {
  it('redacts email & phone in youth threads', () => {
    const r = moderateText('email me john@doe.com or call 555-123-4567', true);
    expect(r.flags.redacted).toBe(true);
    expect(r.redactedText).toContain('[redacted-email]');
    expect(r.redactedText).toContain('[redacted-phone]');
  });
  it('does not redact for adults (but flags)', () => {
    const r = moderateText('visit http://example.com', false);
    expect(r.flags.containsExternalLink).toBe(true);
    expect(r.flags.redacted).toBe(false);
    expect(r.redactedText).toBeUndefined();
  });
});

------------------------------------------------------------
FILE: apps/api/src/tests/messaging.policies.spec.ts
------------------------------------------------------------
import { MessagingPolicies } from '../messaging/http/messaging.policies';

describe('MessagingPolicies', () => {
  it('blocks unverified employer contacting a minor', () => {
    const res = MessagingPolicies.canCreateThread([
      { id: 'minor', isMinor: true, isEmployerVerified: false, role: 'APPLICANT' },
      { id: 'recruiter', isMinor: false, isEmployerVerified: false, role: 'RECRUITER' },
    ] as any);
    expect(res.ok).toBe(false);
  });
  it('allows verified employer + minor', () => {
    const res = MessagingPolicies.canCreateThread([
      { id: 'minor', isMinor: true, isEmployerVerified: false, role: 'APPLICANT' },
      { id: 'recruiter', isMinor: false, isEmployerVerified: true, role: 'RECRUITER' },
    ] as any);
    expect(res.ok).toBe(true);
  });
});

------------------------------------------------------------
FILE: env/api.example.env
------------------------------------------------------------
# Messaging feature flags
LOCKEDIN_MESSAGING_ENABLED=true
# Storage (dev)
LOCKEDIN_ATTACHMENTS_DRIVER=local

------------------------------------------------------------
FILE: README-17.md
------------------------------------------------------------
# Bundle 17 — Direct Messaging & Safety

## What you get
- Prisma schema extension for threads, messages, attachments, reports
- Express routes: create thread, list threads, send message, report message
- Safety policy: minors can be contacted only by verified employers; server ensures compliance
- Moderation: email/phone/links/meet‑up/profanity detection; on‑device warnings + server redaction in youth threads
- Web client: Sidebar, window, input with warnings, safety banner
- WS hooks: typing / read receipts events
- Tests for moderation & policy

## How to integrate
1) Merge `schema.extend.messaging.prisma` into your base Prisma schema and run `prisma migrate dev`.
2) Mount the router in your API: `app.use('/messaging', messagingController)`.
3) Register the WS gateway with your existing socket.io server.
4) Expose a static route for local attachments (dev only) or wire your cloud storage driver.
5) Import web components and add a route to `/messages` in your router. Ensure your `api` client is configured.
6) Gate feature with `LOCKEDIN_MESSAGING_ENABLED` if you want to toggle.

## Notes
- This module deliberately keeps binary upload implementation minimal; replace with your preferred cloud before production.
- Moderation is synchronous & lightweight here. Swap in your async pipeline for better accuracy.
- All PII redaction still stores the original text on the server with `redactedText` for auditing—tighten retention as needed.

END OF BUNDLE 17
