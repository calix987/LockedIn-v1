LOCKEDIN — BUNDLE 16 (Notifications & Activity Feed)
====================================================

Scope
-----
Adds a full notifications system (server + web + shared contracts) and a basic activity feed. 
- Real-time push via WebSocket (re-uses ws gateway from Bundle 15).
- REST endpoints for fetching notifications, marking read, and listing activity.
- React UI: Bell icon with unread badge, dropdown panel, Notifications page, and Activity Feed widget.
- Youth Safety: notifications filtered/redacted for minors; only verified employers can reach minors; external contact info removed for minors.

Assumptions
-----------
- You have Bundle 00–15 in the monorepo with Express + Prisma back end, React + Vite (or Next) front end, shadcn/ui, Tailwind, lucide-react, framer-motion, and a WS gateway established at `ws://.../ws` with auth cookies/JWT.
- User model includes `id`, `age_mode` ('YOUTH' | 'ADULT'), and `email`.
- Auth middleware attaches `req.user` with `id` and `age_mode`.
- No secrets committed (env vars handled already in earlier bundles).

File Layout
-----------
This bundle is written below as "virtual files". Copy them into your repo paths.

------------------------------------------------------------
shared/contracts/notifications.ts
------------------------------------------------------------
export type NotificationType =
  | 'MESSAGE'
  | 'CONNECTION_REQUEST'
  | 'CONNECTION_ACCEPTED'
  | 'POST_MENTION'
  | 'POST_COMMENT'
  | 'POST_LIKE'
  | 'JOB_RECOMMENDATION'
  | 'APPLICATION_STATUS'
  | 'PROFILE_TIP'
  | 'SYSTEM'
  | 'NEW_JOB_MATCH';

export interface NotificationDTO {
  id: string;
  userId: string;
  type: NotificationType;
  title: string;
  body: string;
  data?: Record<string, any>;
  read: boolean;
  createdAt: string; // ISO
  seenAt?: string | null;
}

export interface NotificationListResponse {
  notifications: NotificationDTO[];
  unreadCount: number;
  cursor?: string | null;
}

export interface MarkReadRequest {
  ids: string[];
  read: boolean;
}

export interface NotificationPreferenceDTO {
  id: string;
  userId: string;
  email: boolean;
  push: boolean;
  sms: boolean;
  types?: Record<NotificationType, boolean>;
  quietHoursStart?: number | null; // 0-23
  quietHoursEnd?: number | null;   // 0-23
  createdAt: string;
  updatedAt: string;
}

export interface ActivityDTO {
  id: string;
  actorId: string;
  verb: 'applied' | 'posted' | 'commented' | 'liked' | 'connected' | 'followed' | 'updated_profile';
  objectType: string; // 'job' | 'post' | 'profile' | etc
  objectId: string;
  targetId?: string | null;
  audience: 'PUBLIC' | 'CONNECTIONS' | 'PRIVATE';
  data?: Record<string, any>;
  createdAt: string;
}

export type ActivityFeedScope = 'me' | 'network' | 'global';

------------------------------------------------------------
server/prisma/schema.notifications.prisma (append to your schema)
------------------------------------------------------------
// Enums
enum NotificationType {
  MESSAGE
  CONNECTION_REQUEST
  CONNECTION_ACCEPTED
  POST_MENTION
  POST_COMMENT
  POST_LIKE
  JOB_RECOMMENDATION
  APPLICATION_STATUS
  PROFILE_TIP
  SYSTEM
  NEW_JOB_MATCH
}

enum ActivityAudience {
  PUBLIC
  CONNECTIONS
  PRIVATE
}

// Models
model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  body      String
  data      Json?
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())
  seenAt    DateTime?

  // relations
  user      User             @relation(fields: [userId], references: [id])

  @@index([userId, read, createdAt])
}

model NotificationPreference {
  id               String   @id @default(cuid())
  userId           String   @unique
  email            Boolean  @default(true)
  push             Boolean  @default(true)
  sms              Boolean  @default(false)
  types            Json     // map type->boolean
  quietHoursStart  Int?
  quietHoursEnd    Int?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user             User     @relation(fields: [userId], references: [id])
}

model Activity {
  id         String           @id @default(cuid())
  actorId    String
  verb       String
  objectType String
  objectId   String
  targetId   String?
  audience   ActivityAudience @default(PUBLIC)
  data       Json?
  createdAt  DateTime         @default(now())

  actor      User             @relation("ActivityActor", fields: [actorId], references: [id])

  @@index([createdAt])
  @@index([actorId, createdAt])
}

------------------------------------------------------------
server/src/modules/notifications/types.ts
------------------------------------------------------------
import type { NotificationDTO, NotificationPreferenceDTO, ActivityDTO } from '../../../shared/contracts/notifications';

export type { NotificationDTO, NotificationPreferenceDTO, ActivityDTO };

export type CreateNotificationInput = {
  userId: string;
  type: NotificationDTO['type'];
  title: string;
  body: string;
  data?: Record<string, any>;
};

export type ListNotificationsParams = {
  cursor?: string | null;
  limit?: number;
};

export type ActivityCreateInput = {
  actorId: string;
  verb: 'applied' | 'posted' | 'commented' | 'liked' | 'connected' | 'followed' | 'updated_profile';
  objectType: string;
  objectId: string;
  targetId?: string | null;
  audience?: 'PUBLIC' | 'CONNECTIONS' | 'PRIVATE';
  data?: Record<string, any>;
};

------------------------------------------------------------
server/src/modules/notifications/service.ts
------------------------------------------------------------
import { PrismaClient } from '@prisma/client';
import type { CreateNotificationInput, ListNotificationsParams, ActivityCreateInput } from './types';

const prisma = new PrismaClient();

function isYouth(user: { age_mode?: string }) {
  return user?.age_mode === 'YOUTH';
}

// Redact PII/links for youth
function safeBodyForUser(raw: string, user: { age_mode?: string }) {
  if (!isYouth(user)) return raw;
  // Remove emails, phone numbers, obvious links
  const noEmails = raw.replace(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/gi, '[redacted]');
  const noPhones = noEmails.replace(/(?:\+\d{1,3}\s?)?(?:\(\d{1,4}\)\s?|\d{1,4}[-.\s]?)?\d{3}[-.\s]?\d{4}/g, '[redacted]');
  const noUrls = noPhones.replace(/https?:\/\/\S+/gi, '[redacted]');
  return noUrls;
}

export const NotificationService = {
  async create(input: CreateNotificationInput) {
    // Youth guard: only verified employer job recs can reach minors
    if (input.type === 'JOB_RECOMMENDATION' || input.type === 'NEW_JOB_MATCH') {
      if (input.data?.job?.open_to_minors === true && input.data?.job?.verified_company === true) {
        // allowed
      } else {
        // If target user is a minor, drop or convert to generic tip
        const target = await prisma.user.findUnique({ where: { id: input.userId } });
        if (isYouth(target)) {
          input.type = 'PROFILE_TIP';
          input.title = 'New roles are available';
          input.body = 'New roles are available from verified employers. Update your profile to improve matches.';
          input.data = {};
        }
      }
    }

    const created = await prisma.notification.create({
      data: {
        userId: input.userId,
        type: input.type as any,
        title: input.title,
        body: input.body,
        data: input.data ?? {},
      },
    });

    // Push over WS (if gateway exists)
    try {
      const { pushToUser } = require('../../ws/gateway'); // optional: your ws helper
      if (pushToUser) {
        pushToUser(input.userId, 'notification:new', { id: created.id });
      }
    } catch (e) {
      // ws optional
    }
    return created;
  },

  async list(userId: string, params: ListNotificationsParams & { user: any }) {
    const limit = Math.min(Math.max(params.limit ?? 20, 1), 50);
    const cursor = params.cursor ? { id: params.cursor } : undefined;

    const items = await prisma.notification.findMany({
      where: { userId },
      take: limit,
      skip: cursor ? 1 : 0,
      cursor,
      orderBy: { createdAt: 'desc' },
    });

    const user = params.user || {};
    const sanitized = items.map((n) => ({
      ...n,
      body: safeBodyForUser(n.body, user),
    }));

    const unreadCount = await prisma.notification.count({ where: { userId, read: false } });

    const nextCursor = items.length === limit ? items[items.length - 1].id : null;
    return { notifications: sanitized, unreadCount, cursor: nextCursor };
  },

  async markRead(userId: string, ids: string[], read: boolean) {
    await prisma.notification.updateMany({
      where: { userId, id: { in: ids } },
      data: { read: !!read, seenAt: read ? new Date() : null },
    });
    return { ok: true };
  },

  async markAllRead(userId: string) {
    await prisma.notification.updateMany({
      where: { userId, read: false },
      data: { read: true, seenAt: new Date() },
    });
    return { ok: true };
  },
};

export const ActivityService = {
  async create(input: ActivityCreateInput) {
    const created = await prisma.activity.create({
      data: {
        actorId: input.actorId,
        verb: input.verb,
        objectType: input.objectType,
        objectId: input.objectId,
        targetId: input.targetId ?? null,
        audience: (input.audience ?? 'PUBLIC') as any,
        data: input.data ?? {},
      },
    });

    // Broadcast to interested users
    try {
      const { broadcast } = require('../../ws/gateway');
      if (broadcast) {
        broadcast('activity:new', { id: created.id, verb: created.verb });
      }
    } catch {}

    return created;
  },

  async feed(userId: string, scope: 'me' | 'network' | 'global', limit = 20) {
    // Simplified: for "network", show PUBLIC/CONNECTIONS from followed users;
    // Here we assume a "connection" table exists. If not, return PUBLIC global.
    const prismaWhere: any = {};
    if (scope === 'me') {
      prismaWhere.actorId = userId;
    } else if (scope === 'network') {
      // naive: join connections table
      try {
        const connections = await prisma.connection.findMany({
          where: {
            OR: [
              { userAId: userId, status: 'CONNECTED' },
              { userBId: userId, status: 'CONNECTED' },
            ],
          },
          select: { userAId: true, userBId: true },
        });
        const ids = new Set<string>();
        connections.forEach((c: any) => {
          if (c.userAId !== userId) ids.add(c.userAId);
          if (c.userBId !== userId) ids.add(c.userBId);
        });
        prismaWhere.actorId = { in: Array.from(ids) };
        prismaWhere.audience = { in: ['PUBLIC', 'CONNECTIONS'] };
      } catch {
        prismaWhere.audience = 'PUBLIC';
      }
    } else {
      prismaWhere.audience = 'PUBLIC';
    }

    const items = await prisma.activity.findMany({
      where: prismaWhere,
      take: limit,
      orderBy: { createdAt: 'desc' },
    });
    return items;
  },
};

------------------------------------------------------------
server/src/modules/notifications/router.ts
------------------------------------------------------------
import { Router } from 'express';
import { NotificationService, ActivityService } from './service';

export const notificationsRouter = Router();

// GET /api/notifications?cursor=&limit=
notificationsRouter.get('/', async (req: any, res) => {
  const userId = req.user?.id;
  if (!userId) return res.status(401).json({ error: 'Unauthorized' });
  const { cursor, limit } = req.query as any;
  const data = await NotificationService.list(userId, { cursor: cursor ?? null, limit: limit ? Number(limit) : 20, user: req.user });
  res.json(data);
});

// POST /api/notifications/mark-read
notificationsRouter.post('/mark-read', async (req: any, res) => {
  const userId = req.user?.id;
  if (!userId) return res.status(401).json({ error: 'Unauthorized' });
  const { ids, read } = req.body as { ids: string[]; read: boolean };
  if (!Array.isArray(ids) || typeof read !== 'boolean') return res.status(400).json({ error: 'Invalid body' });
  await NotificationService.markRead(userId, ids, read);
  res.json({ ok: true });
});

// POST /api/notifications/mark-all-read
notificationsRouter.post('/mark-all-read', async (req: any, res) => {
  const userId = req.user?.id;
  if (!userId) return res.status(401).json({ error: 'Unauthorized' });
  await NotificationService.markAllRead(userId);
  res.json({ ok: true });
});

// Activity endpoints
// GET /api/activity?scope=me|network|global&limit=20
notificationsRouter.get('/activity', async (req: any, res) => {
  const userId = req.user?.id;
  if (!userId) return res.status(401).json({ error: 'Unauthorized' });
  const scope = (req.query.scope as any) || 'network';
  const limit = req.query.limit ? Number(req.query.limit) : 20;
  const items = await ActivityService.feed(userId, scope, limit);
  res.json({ items });
});

// POST /api/activity (internal or trusted callers)
notificationsRouter.post('/activity', async (req: any, res) => {
  const userId = req.user?.id;
  if (!userId) return res.status(401).json({ error: 'Unauthorized' });
  // In production, verify the actorId === userId or system role.
  const input = req.body;
  const created = await ActivityService.create(input);
  res.json({ created });
});

------------------------------------------------------------
server/src/ws/gateway.ts (augment if exists)
------------------------------------------------------------
// Minimal helper used by service.ts. If you already have a gateway, keep yours.
import type { WebSocketServer } from 'ws';

let wss: WebSocketServer | null = null;
// Map userId -> Set of sockets
const userSockets = new Map<string, Set<any>>();

export function initWs(server: WebSocketServer) {
  wss = server;
  server.on('connection', (socket: any, req: any) => {
    const userId = req.user?.id; // attach via your ws auth layer
    if (!userId) return socket.close();

    if (!userSockets.has(userId)) userSockets.set(userId, new Set());
    userSockets.get(userId)!.add(socket);

    socket.on('close', () => {
      userSockets.get(userId)?.delete(socket);
    });
  });
}

export function pushToUser(userId: string, event: string, payload: any) {
  const set = userSockets.get(userId);
  if (!set) return;
  const msg = JSON.stringify({ event, payload });
  set.forEach((s) => s.send(msg));
}

export function broadcast(event: string, payload: any) {
  if (!wss) return;
  const msg = JSON.stringify({ event, payload });
  wss.clients.forEach((client: any) => {
    if (client.readyState === 1) client.send(msg);
  });
}

------------------------------------------------------------
server/src/app.ts (wire router)
------------------------------------------------------------
// import { notificationsRouter } from './modules/notifications/router';
// app.use('/api/notifications', authMiddleware, notificationsRouter);
// Also ensure ws gateway is initialized in your server bootstrap.

------------------------------------------------------------
web/src/lib/api/notifications.ts
------------------------------------------------------------
import type { NotificationListResponse, MarkReadRequest, ActivityDTO } from '../../../../shared/contracts/notifications';

export async function listNotifications(params?: { cursor?: string | null; limit?: number }): Promise<NotificationListResponse> {
  const url = new URL('/api/notifications', window.location.origin);
  if (params?.cursor) url.searchParams.set('cursor', params.cursor);
  if (params?.limit) url.searchParams.set('limit', String(params.limit));
  const res = await fetch(url.toString(), { credentials: 'include' });
  if (!res.ok) throw new Error('Failed to fetch notifications');
  return res.json();
}

export async function markRead(body: MarkReadRequest): Promise<{ ok: true }> {
  const res = await fetch('/api/notifications/mark-read', {
    method: 'POST',
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  });
  if (!res.ok) throw new Error('Failed to mark read');
  return res.json();
}

export async function markAllRead(): Promise<{ ok: true }> {
  const res = await fetch('/api/notifications/mark-all-read', {
    method: 'POST',
    credentials: 'include',
  });
  if (!res.ok) throw new Error('Failed to mark all read');
  return res.json();
}

export async function getActivity(scope: 'me' | 'network' | 'global' = 'network', limit = 20): Promise<{ items: ActivityDTO[] }> {
  const url = new URL('/api/notifications/activity', window.location.origin);
  url.searchParams.set('scope', scope);
  url.searchParams.set('limit', String(limit));
  const res = await fetch(url.toString(), { credentials: 'include' });
  if (!res.ok) throw new Error('Failed to fetch activity');
  return res.json();
}

------------------------------------------------------------
web/src/features/notifications/NotificationsBell.tsx
------------------------------------------------------------
import React, { useEffect, useState } from 'react';
import { BellIcon } from 'lucide-react';
import { listNotifications } from '../../lib/api/notifications';
import { Button } from '@/components/ui/button';

type Props = { onOpen?: () => void };

export default function NotificationsBell({ onOpen }: Props) {
  const [unread, setUnread] = useState(0);

  async function refresh() {
    try {
      const data = await listNotifications({ limit: 1 });
      setUnread(data.unreadCount);
    } catch {}
  }

  useEffect(() => {
    refresh();
    // subscribe WS
    const socket = (window as any).__ws as WebSocket | undefined;
    function onMessage(ev: MessageEvent) {
      try {
        const msg = JSON.parse(ev.data);
        if (msg.event === 'notification:new') refresh();
      } catch {}
    }
    socket?.addEventListener('message', onMessage);
    return () => socket?.removeEventListener('message', onMessage);
  }, []);

  return (
    <Button variant="ghost" className="relative" onClick={onOpen}>
      <BellIcon className="w-5 h-5" />
      {unread > 0 && (
        <span className="absolute -top-1 -right-1 bg-red-500 text-white text-[10px] px-1.5 py-0.5 rounded-full">
          {unread > 99 ? '99+' : unread}
        </span>
      )}
    </Button>
  );
}

------------------------------------------------------------
web/src/features/notifications/NotificationsPanel.tsx
------------------------------------------------------------
import React, { useEffect, useState } from 'react';
import { listNotifications, markRead } from '../../lib/api/notifications';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';

export default function NotificationsPanel() {
  const [items, setItems] = useState<any[]>([]);
  const [cursor, setCursor] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  async function load(initial = false) {
    setLoading(true);
    try {
      const data = await listNotifications(initial ? { limit: 15 } : { cursor, limit: 15 });
      setItems((prev) => (initial ? data.notifications : [...prev, ...data.notifications]));
      setCursor(data.cursor ?? null);
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => { load(true); }, []);

  async function markSelectedRead(ids: string[]) {
    if (!ids.length) return;
    await markRead({ ids, read: true });
    setItems((prev) => prev.map((n) => (ids.includes(n.id) ? { ...n, read: true } : n)));
  }

  return (
    <Card className="w-full md:w-[420px] p-3 bg-white/90 backdrop-blur">
      <div className="flex items-center justify-between px-2 pb-2 border-b">
        <div className="font-semibold">Notifications</div>
        <Button variant="outline" size="sm" onClick={() => markSelectedRead(items.filter(i => !i.read).map(i => i.id))}>
          Mark all read
        </Button>
      </div>
      <div className="max-h-[70vh] overflow-auto divide-y">
        {items.map((n) => (
          <div key={n.id} className="p-3 hover:bg-indigo-50/40 transition">
            <div className="flex items-start justify-between gap-2">
              <div>
                <div className="font-medium text-gray-900">{n.title}</div>
                <div className={`text-sm ${n.read ? 'text-gray-500' : 'text-gray-700'}`}>{n.body}</div>
                {n.data?.job && (
                  <div className="mt-1">
                    <Badge className="bg-emerald-100 text-emerald-800 mr-2">Job</Badge>
                    <span className="text-xs text-gray-600">{n.data.job.title} — {n.data.job.company}</span>
                  </div>
                )}
              </div>
              {!n.read && (
                <Button variant="ghost" size="sm" onClick={() => markSelectedRead([n.id])}>
                  Mark read
                </Button>
              )}
            </div>
            <div className="mt-1 text-[11px] text-gray-400">{new Date(n.createdAt).toLocaleString()}</div>
          </div>
        ))}
        {cursor && (
          <div className="p-3">
            <Button className="w-full" disabled={loading} onClick={() => load()}>
              {loading ? 'Loading…' : 'Load more'}
            </Button>
          </div>
        )}
        {!items.length && <div className="p-6 text-center text-gray-500">No notifications yet</div>}
      </div>
    </Card>
  );
}

------------------------------------------------------------
web/src/features/activity/ActivityFeed.tsx
------------------------------------------------------------
import React, { useEffect, useState } from 'react';
import { getActivity } from '../../lib/api/notifications';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';

type Props = { scope?: 'me' | 'network' | 'global' };

export default function ActivityFeed({ scope = 'network' }: Props) {
  const [items, setItems] = useState<any[]>([]);

  async function load() {
    const { items } = await getActivity(scope, 20);
    setItems(items);
  }

  useEffect(() => { load(); }, [scope]);

  const labels: Record<string, string> = {
    applied: 'applied to a job',
    posted: 'posted an update',
    commented: 'commented',
    liked: 'liked',
    connected: 'connected with someone',
    followed: 'followed someone',
    updated_profile: 'updated their profile',
  };

  return (
    <Card className="p-4 bg-white/90 backdrop-blur">
      <div className="font-semibold mb-2">Activity</div>
      <div className="space-y-3">
        {items.map((a) => (
          <div key={a.id} className="text-sm">
            <span className="font-medium">Someone</span> {labels[a.verb] ?? a.verb}
            {a.objectType === 'job' && a.data?.jobTitle && (
              <span> — <Badge>{a.data.jobTitle}</Badge></span>
            )}
            <div className="text-[11px] text-gray-400">{new Date(a.createdAt).toLocaleString()}</div>
          </div>
        ))}
        {!items.length && <div className="text-gray-500 text-sm">Nothing yet.</div>}
      </div>
    </Card>
  );
}

------------------------------------------------------------
web/src/pages/NotificationsPage.tsx
------------------------------------------------------------
import React from 'react';
import NotificationsPanel from '@/features/notifications/NotificationsPanel';

export default function NotificationsPage() {
  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 via-white to-blue-50 p-6 md:p-8">
      <div className="max-w-3xl mx-auto">
        <h1 className="text-2xl font-bold text-gray-900 mb-4">Notifications</h1>
        <NotificationsPanel />
      </div>
    </div>
  );
}

------------------------------------------------------------
web/src/layout/HeaderWithBell.tsx (optional header integration)
------------------------------------------------------------
import React, { useState } from 'react';
import NotificationsBell from '@/features/notifications/NotificationsBell';
import NotificationsPanel from '@/features/notifications/NotificationsPanel';

export default function HeaderWithBell() {
  const [open, setOpen] = useState(false);
  return (
    <div className="relative">
      <NotificationsBell onOpen={() => setOpen(!open)} />
      {open && (
        <div className="absolute right-0 mt-2 z-50">
          <NotificationsPanel />
        </div>
      )}
    </div>
  );
}

------------------------------------------------------------
Integration Notes
-----------------
1) Prisma:
   - Append models/enums to your main `schema.prisma` (or import this file). Run:
     npx prisma generate
     npx prisma migrate dev -n "notifications_activity"

2) Server:
   - Mount router in `app.ts`:
     import { notificationsRouter } from './modules/notifications/router';
     app.use('/api/notifications', authMiddleware, notificationsRouter);

   - Ensure WS gateway is initialized and your ws auth sets `req.user` on upgrades.

3) Web:
   - Add a route for NotificationsPage (e.g., `/notifications`) to your router.
   - In your main header or layout, render <HeaderWithBell /> near the user avatar.
   - Tailwind/shadcn already available from previous bundles.

4) Youth Safety Defaults:
   - All `NotificationService.create` calls for job recommendations pass through checks to ensure verified employers for minors.
   - Body strings are redacted for minors to remove emails/phones/urls.

5) Test Data (server console / seed script pseudo):
   await NotificationService.create({
     userId: 'USER_ID',
     type: 'JOB_RECOMMENDATION',
     title: 'New SWE Intern role',
     body: 'A verified employer posted a role that matches your skills.',
     data: { job: { title: 'SWE Intern', company: 'Acme', verified_company: true, open_to_minors: true } }
   });

   await ActivityService.create({
     actorId: 'USER_ID',
     verb: 'applied',
     objectType: 'job',
     objectId: 'JOB_ID',
     data: { jobTitle: 'SWE Intern' }
   });

Changelog
---------
- New Prisma models for Notification, NotificationPreference, Activity
- REST + WS integration for real-time notifications
- React UI: bell + panel + notifications page + activity feed widget
- Youth-safety guards and redaction

Done.
