=== path: bundles/10-feed-posts/README.md ===
# Bundle 10 — Feed & Posts (Home, Composer, Reactions, Comments, Shares)

This bundle adds a safe-by-default social feed with posting, comments, reactions, shares, and basic ranking. It respects Youth-Safe mode (under-18), verified-employer rules, and moderation hooks. It builds on earlier bundles (Auth, Users, Safety, Messaging).

## What you get
- Prisma models: `Post`, `Comment`, `Reaction`, `Share` (as field on Post), and enums.
- REST API routes under `/api/posts` and `/api/feed` with Zod validation.
- Feed ranking module (pluggable) with recency + lightweight engagement.
- Safety checks (stub) calling `SafetyService.moderatePost` and age-mode filters.
- React frontend:
  - **FeedPage** with infinite scroll
  - **PostComposer** (rich text-lite, tags, media URLs)
  - **PostCard** (reactions, share, comment sheet)
  - **CommentsSheet** (lazy-load & post new)
- Web entities: `Post` client with `listFeed`, `create`, `react`, `comment`, `share`.
- Sidebar/Home link and route registration.

## Pre-reqs
- Bundle 00–09 + Safety service available at `@/server/services/safetyService`.
- Auth middleware sets `req.user` with `{ id, age_mode, is_verified_employer, ... }`.
- Prisma & Postgres with vector/text search enabled (optional).

## Apply
1) Merge files preserving paths.
2) Run Prisma migration:
   ```bash
   npx prisma migrate dev --name add_posts_feed
   npx prisma generate
   ```
3) Rebuild and restart API & Web apps.
4) Seed with sample posts (optional API in this bundle).

## Notes
- Youth-Safe mode filters: hides flagged content; only shows posts from verified employers and verified users if configured. Media links are sanitized.
- Ranking is intentionally simple; replace `rankFeed.ts` with your ML when ready.
- Attachment uploads are **URL-based** placeholders; swap with your upload service later.
- All API responses are paginated using `cursor` + `limit`.

---

=== path: packages/db/prisma/schema.prisma ===
/// Append the following models & enums to your existing Prisma schema.

enum Visibility {
  PUBLIC
  CONNECTIONS
  PRIVATE
}

enum ReactionType {
  LIKE
  CELEBRATE
  SUPPORT
  LOVE
  INSIGHTFUL
  CURIOUS
}

enum ContentStatus {
  ACTIVE
  FLAGGED
  REMOVED
}

model Post {
  id             String         @id @default(cuid())
  authorId       String
  author         User           @relation(fields: [authorId], references: [id])
  content        String         @db.Text
  richContent    Json?
  mediaUrls      String[]       @default([])
  hashtags       String[]       @default([])
  mentions       String[]       @default([])
  visibility     Visibility     @default(PUBLIC)
  status         ContentStatus  @default(ACTIVE)
  isYouthSafe    Boolean        @default(true)
  likeCount      Int            @default(0)
  commentCount   Int            @default(0)
  shareCount     Int            @default(0)
  parentPostId   String?
  parentPost     Post?          @relation("ShareRef", fields: [parentPostId], references: [id])
  shares         Post[]         @relation("ShareRef")
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  comments       Comment[]
  reactions      Reaction[]

  @@index([authorId, createdAt])
  @@index([createdAt])
  @@index([status])
}

model Comment {
  id           String        @id @default(cuid())
  postId       String
  post         Post          @relation(fields: [postId], references: [id])
  authorId     String
  author       User          @relation(fields: [authorId], references: [id])
  content      String        @db.Text
  status       ContentStatus @default(ACTIVE)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  reactions    CommentReaction[]

  @@index([postId, createdAt])
}

model Reaction {
  id        String       @id @default(cuid())
  postId    String
  post      Post         @relation(fields: [postId], references: [id])
  userId    String
  user      User         @relation(fields: [userId], references: [id])
  type      ReactionType @default(LIKE)
  createdAt DateTime     @default(now())

  @@unique([postId, userId])
  @@index([userId, createdAt])
}

model CommentReaction {
  id        String       @id @default(cuid())
  commentId String
  comment   Comment      @relation(fields: [commentId], references: [id])
  userId    String
  user      User         @relation(fields: [userId], references: [id])
  type      ReactionType @default(LIKE)
  createdAt DateTime     @default(now())

  @@unique([commentId, userId])
}

---

=== path: apps/api/src/validators/postSchemas.ts ===
import { z } from "zod";

export const createPostSchema = z.object({
  content: z.string().min(1).max(5000),
  mediaUrls: z.array(z.string().url()).max(6).optional(),
  visibility: z.enum(["PUBLIC", "CONNECTIONS", "PRIVATE"]).default("PUBLIC"),
  richContent: z.any().optional(),
  hashtags: z.array(z.string().regex(/^#[A-Za-z0-9_]{1,50}$/)).max(30).optional(),
  mentions: z.array(z.string()).max(30).optional(),
  parentPostId: z.string().cuid().optional(),
});

export const listFeedSchema = z.object({
  cursor: z.string().optional(),
  limit: z.coerce.number().min(1).max(50).default(20),
  scope: z.enum(["HOME", "USER", "COMPANY"]).default("HOME"),
  userId: z.string().optional(),
  companyId: z.string().optional(),
});

export const reactSchema = z.object({
  type: z.enum(["LIKE", "CELEBRATE", "SUPPORT", "LOVE", "INSIGHTFUL", "CURIOUS"]),
});

export const commentSchema = z.object({
  content: z.string().min(1).max(3000),
});

---

=== path: apps/api/src/services/rankFeed.ts ===
/**
 * Basic feed ranking: recency + lightweight engagement.
 * Replace with ML later. Output a numeric score; higher = earlier in feed.
 */
export function rankScore(post: {
  createdAt: Date;
  likeCount: number;
  commentCount: number;
  shareCount: number;
  connectionBoost?: number; // 0..1
  youthSafe?: boolean;
}) {
  const ageHours = (Date.now() - post.createdAt.getTime()) / (1000 * 60 * 60);
  const recency = Math.max(0, 48 - ageHours) / 48; // 0..1 for last 48h
  const engagement = Math.min(1, (post.likeCount * 1 + post.commentCount * 2 + post.shareCount * 3) / 50);
  const connection = Math.min(1, post.connectionBoost ?? 0);
  const safety = post.youthSafe === false ? 0 : 0.05; // tiny bump for youth-safe
  return recency * 0.55 + engagement * 0.3 + connection * 0.1 + safety * 0.05;
}

---

=== path: apps/api/src/routes/posts.ts ===
import { Router } from "express";
import { z } from "zod";
import { prisma } from "@/prisma";
import { createPostSchema, listFeedSchema, reactSchema, commentSchema } from "@/validators/postSchemas";
import { rankScore } from "@/services/rankFeed";
import { moderatePost } from "@/services/safetyService"; // stubbed API

const router = Router();

// Auth guard assumed globally; req.user is populated
function requireAuth(req, res, next) {
  if (!req.user) return res.status(401).json({ error: "Unauthorized" });
  next();
}

router.post("/posts", requireAuth, async (req, res) => {
  const parse = createPostSchema.safeParse(req.body);
  if (!parse.success) return res.status(400).json({ error: parse.error.flatten() });
  const { content, mediaUrls = [], visibility, richContent, hashtags = [], mentions = [], parentPostId } = parse.data;

  // Safety moderation
  const safety = await moderatePost({
    authorId: req.user.id,
    ageMode: req.user.age_mode,
    content,
    mediaUrls,
  });
  if (!safety.allowed) {
    return res.status(400).json({ error: "Content blocked by safety policy", details: safety.labels });
  }

  const post = await prisma.post.create({
    data: {
      authorId: req.user.id,
      content,
      mediaUrls,
      visibility,
      richContent,
      hashtags,
      mentions,
      isYouthSafe: safety.isYouthSafe ?? true,
      parentPostId: parentPostId ?? null,
    },
    include: {
      author: true,
    },
  });

  res.json({ post });
});

router.get("/feed", requireAuth, async (req, res) => {
  const parse = listFeedSchema.safeParse(req.query);
  if (!parse.success) return res.status(400).json({ error: parse.error.flatten() });
  const { cursor, limit, scope, userId, companyId } = parse.data;

  // Base filter: active only
  let where: any = { status: "ACTIVE" };

  // Visibility filter
  // (Simplified) PRIVATE posts only visible to author; CONNECTIONS requires connection relation (TODO: implement)
  where.OR = [
    { visibility: "PUBLIC" },
    { authorId: req.user.id },
  ];

  // Scope filters (HOME shows connections + follows later; for now public + own)
  if (scope === "USER" && userId) {
    where.authorId = userId;
  }

  // Youth-Safe mode
  if (req.user.age_mode === "YOUTH") {
    where.isYouthSafe = true;
    // Optionally only verified employers & verified users (toggle in config)
  }

  const posts = await prisma.post.findMany({
    where,
    orderBy: { createdAt: "desc" },
    take: limit + 1,
    ...(cursor ? { cursor: { id: String(cursor) }, skip: 1 } : {}),
    include: {
      author: true,
    },
  });

  const items = posts.slice(0, limit);

  // Rank (recency already applied; mix in score for future)
  const ranked = items
    .map(p => ({
      ...p,
      _score: rankScore({
        createdAt: p.createdAt,
        likeCount: p.likeCount,
        commentCount: p.commentCount,
        shareCount: p.shareCount,
        connectionBoost: 0.05,
        youthSafe: p.isYouthSafe,
      }),
    }))
    .sort((a, b) => b._score - a._score);

  const nextCursor = posts.length > limit ? posts[limit].id : null;

  res.json({ items: ranked, nextCursor });
});

router.get("/posts/:id", requireAuth, async (req, res) => {
  const post = await prisma.post.findUnique({
    where: { id: String(req.params.id) },
    include: { author: true },
  });
  if (!post) return res.status(404).json({ error: "Not found" });
  if (req.user.age_mode === "YOUTH" && !post.isYouthSafe) return res.status(403).json({ error: "Restricted content" });
  res.json({ post });
});

router.post("/posts/:id/react", requireAuth, async (req, res) => {
  const parse = reactSchema.safeParse(req.body);
  if (!parse.success) return res.status(400).json({ error: parse.error.flatten() });
  const postId = String(req.params.id);

  try {
    await prisma.reaction.upsert({
      where: { postId_userId: { postId, userId: req.user.id } },
      create: { postId, userId: req.user.id, type: parse.data.type },
      update: { type: parse.data.type },
    });
    // Update counters (optimistic)
    await prisma.post.update({
      where: { id: postId },
      data: { likeCount: { increment: 1 } },
    });
  } catch (e) {}

  res.json({ ok: true });
});

router.delete("/posts/:id/react", requireAuth, async (req, res) => {
  const postId = String(req.params.id);
  await prisma.reaction.deleteMany({
    where: { postId, userId: req.user.id },
  });
  res.json({ ok: true });
});

router.post("/posts/:id/comments", requireAuth, async (req, res) => {
  const parse = commentSchema.safeParse(req.body);
  if (!parse.success) return res.status(400).json({ error: parse.error.flatten() });
  const postId = String(req.params.id);
  const post = await prisma.post.findUnique({ where: { id: postId } });
  if (!post) return res.status(404).json({ error: "Post not found" });
  if (req.user.age_mode === "YOUTH" && !post.isYouthSafe) return res.status(403).json({ error: "Restricted content" });

  // Safety
  const safety = await moderatePost({ authorId: req.user.id, ageMode: req.user.age_mode, content: parse.data.content, mediaUrls: [] });
  if (!safety.allowed) return res.status(400).json({ error: "Comment blocked", details: safety.labels });

  const comment = await prisma.comment.create({
    data: {
      postId,
      authorId: req.user.id,
      content: parse.data.content,
      status: "ACTIVE",
    },
    include: { author: true },
  });
  await prisma.post.update({
    where: { id: postId },
    data: { commentCount: { increment: 1 } },
  });
  res.json({ comment });
});

router.get("/posts/:id/comments", requireAuth, async (req, res) => {
  const postId = String(req.params.id);
  const comments = await prisma.comment.findMany({
    where: { postId, status: "ACTIVE" },
    orderBy: { createdAt: "asc" },
    include: { author: true },
    take: 100,
  });
  res.json({ items: comments });
});

router.delete("/posts/:id", requireAuth, async (req, res) => {
  const id = String(req.params.id);
  const post = await prisma.post.findUnique({ where: { id } });
  if (!post) return res.status(404).json({ error: "Not found" });
  if (post.authorId !== req.user.id && !req.user.is_admin) return res.status(403).json({ error: "Forbidden" });
  await prisma.post.update({ where: { id }, data: { status: "REMOVED" } });
  res.json({ ok: true });
});

export default router;

---

=== path: apps/api/src/services/safetyService.ts ===
/**
 * Stub to integrate with your Safety/Moderation bundle.
 * Return { allowed: boolean, labels?: string[], isYouthSafe?: boolean }
 */
export async function moderatePost(input: {
  authorId: string;
  ageMode: "YOUTH" | "ADULT";
  content: string;
  mediaUrls: string[];
}): Promise<{ allowed: boolean; labels?: string[]; isYouthSafe?: boolean; }> {
  // TODO: replace with real checks (keywords, image scan, RAG policy)
  const banned = ["in-person meetup", "cash only", "dm for address"];
  const text = input.content.toLowerCase();
  if (banned.some(b => text.includes(b))) {
    return { allowed: false, labels: ["policy_violation"] };
  }
  const isYouthSafe = !/inappropriate|adult|explicit/i.test(text);
  return { allowed: true, isYouthSafe };
}

---

=== path: apps/web/src/entities/post.ts ===
import { api } from "@/lib/api";

export type PostType = {
  id: string;
  authorId: string;
  content: string;
  mediaUrls: string[];
  visibility: "PUBLIC" | "CONNECTIONS" | "PRIVATE";
  isYouthSafe: boolean;
  likeCount: number;
  commentCount: number;
  shareCount: number;
  createdAt: string;
  author?: any;
};

export const Post = {
  async create(payload: {
    content: string;
    mediaUrls?: string[];
    visibility?: "PUBLIC" | "CONNECTIONS" | "PRIVATE";
    hashtags?: string[];
    mentions?: string[];
    parentPostId?: string;
  }): Promise<PostType> {
    const res = await api.post("/posts", payload);
    return res.post as PostType;
  },

  async listFeed(params?: { cursor?: string; limit?: number; scope?: "HOME"|"USER"|"COMPANY"; userId?: string; }): Promise<{ items: PostType[]; nextCursor: string | null; }> {
    const res = await api.get("/feed", params ?? {});
    return res as any;
  },

  async get(id: string): Promise<PostType> {
    const res = await api.get(`/posts/${id}`);
    return res.post as PostType;
  },

  async react(id: string, type: "LIKE"|"CELEBRATE"|"SUPPORT"|"LOVE"|"INSIGHTFUL"|"CURIOUS") {
    await api.post(`/posts/${id}/react`, { type });
  },

  async unreact(id: string) {
    await api.delete(`/posts/${id}/react`);
  },

  async comment(id: string, content: string) {
    const res = await api.post(`/posts/${id}/comments`, { content });
    return res.comment;
  },

  async listComments(id: string) {
    const res = await api.get(`/posts/${id}/comments`);
    return res.items;
  },
};

---

=== path: apps/web/src/entities/all.ts ===
/** Append Post export to your aggregator */
export * from "@/entities/post";

---

=== path: apps/web/src/pages/Feed.tsx ===
import React, { useEffect, useState } from "react";
import { Post, PostType } from "@/entities/post";
import { User } from "@/entities/all";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Separator } from "@/components/ui/separator";
import { 
  ImageIcon, PaperclipIcon, HashIcon, SendHorizonalIcon, HeartIcon, MessagesSquareIcon, Share2Icon, GlobeIcon, UsersIcon, LockIcon 
} from "lucide-react";
import { motion } from "framer-motion";

type Visibility = "PUBLIC" | "CONNECTIONS" | "PRIVATE";

const visibilityIcon: Record<Visibility, React.ReactNode> = {
  PUBLIC: <GlobeIcon className="w-4 h-4" />,
  CONNECTIONS: <UsersIcon className="w-4 h-4" />,
  PRIVATE: <LockIcon className="w-4 h-4" />,
};

function initials(name?: string) {
  if (!name) return "U";
  return name.split(" ").slice(0,2).map(s => s[0]).join("").toUpperCase();
}

const PostComposer: React.FC<{ onPost: (payload: any)=>Promise<void>; user: any; }> = ({ onPost, user }) => {
  const [content, setContent] = useState("");
  const [visibility, setVisibility] = useState<Visibility>("PUBLIC");
  const [hashtags, setHashtags] = useState<string[]>([]);
  const [mediaUrls, setMediaUrls] = useState<string[]>([]);
  const [pendingTag, setPendingTag] = useState("");
  const [isPosting, setIsPosting] = useState(false);

  const addTag = () => {
    const t = pendingTag.trim();
    if (t) {
      const tag = t.startsWith("#") ? t : `#${t}`;
      setHashtags(prev => Array.from(new Set([...prev, tag])));
      setPendingTag("");
    }
  };

  const addMedia = () => {
    const u = prompt("Paste an image/file URL (temporary placeholder):");
    if (u) setMediaUrls(prev => [...prev, u]);
  };

  const submit = async () => {
    if (!content.trim()) return;
    setIsPosting(true);
    try {
      await onPost({ content, visibility, hashtags, mediaUrls });
      setContent("");
      setHashtags([]);
      setMediaUrls([]);
      setVisibility("PUBLIC");
    } finally {
      setIsPosting(false);
    }
  };

  return (
    <Card className="bg-white/90 border border-gray-200/60 shadow-md">
      <CardContent className="p-4">
        <div className="flex gap-3">
          <Avatar>
            <AvatarFallback>{initials(user?.full_name)}</AvatarFallback>
          </Avatar>
          <div className="flex-1">
            <Textarea
              placeholder="Share an update, project, or question..."
              value={content}
              onChange={(e) => setContent(e.target.value)}
              className="min-h-[80px]"
            />
            {hashtags.length > 0 && (
              <div className="flex flex-wrap gap-1 mt-2">
                {hashtags.map(h => <Badge key={h} variant="secondary"><HashIcon className="w-3 h-3 mr-1" />{h}</Badge>)}
              </div>
            )}
            {mediaUrls.length > 0 && (
              <div className="flex flex-wrap gap-2 mt-2 text-xs text-gray-600">
                {mediaUrls.map((m, i) => <span key={i} className="underline">{m}</span>)}
              </div>
            )}
            <div className="flex items-center justify-between mt-3">
              <div className="flex gap-2">
                <Button type="button" variant="ghost" size="sm" onClick={addMedia}><ImageIcon className="w-4 h-4 mr-1" />Media</Button>
                <div className="flex items-center gap-2">
                  <Input placeholder="#tag" value={pendingTag} onChange={e=>setPendingTag(e.target.value)} className="h-8 w-28" />
                  <Button variant="secondary" size="sm" onClick={addTag}>Add</Button>
                </div>
              </div>
              <div className="flex items-center gap-2">
                <select value={visibility} onChange={e=>setVisibility(e.target.value as Visibility)} className="h-9 px-2 border rounded-md text-sm">
                  <option value="PUBLIC">Public</option>
                  <option value="CONNECTIONS">Connections</option>
                  <option value="PRIVATE">Private</option>
                </select>
                <Button onClick={submit} disabled={isPosting || !content.trim()} className="bg-indigo-600 text-white">
                  {isPosting ? "Posting..." : (<><SendHorizonalIcon className="w-4 h-4 mr-1" />Post</>)}
                </Button>
              </div>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

const PostCard: React.FC<{
  post: PostType;
  onReact: (id: string)=>Promise<void>;
  onComment: (id: string, content: string)=>Promise<void>;
}> = ({ post, onReact, onComment }) => {
  const [commentDraft, setCommentDraft] = useState("");

  const submitComment = async () => {
    if (!commentDraft.trim()) return;
    await onComment(post.id, commentDraft);
    setCommentDraft("");
  };

  return (
    <Card className="bg-white/90 border border-gray-200/60 shadow hover:shadow-md transition">
      <CardContent className="p-4">
        <div className="flex gap-3">
          <Avatar><AvatarFallback>{initials(post.author?.full_name)}</AvatarFallback></Avatar>
          <div className="flex-1">
            <div className="flex items-center gap-2">
              <div className="font-semibold text-gray-900">{post.author?.full_name ?? "User"}</div>
              <Separator orientation="vertical" className="h-4" />
              <div className="text-xs text-gray-500 flex items-center gap-1">{visibilityIcon[post.visibility]} {post.visibility}</div>
              <div className="text-xs text-gray-400 ml-auto">{new Date(post.createdAt).toLocaleString()}</div>
            </div>
            <div className="mt-2 whitespace-pre-wrap text-gray-900">{post.content}</div>
            {post.mediaUrls?.length > 0 && (
              <div className="grid grid-cols-2 gap-2 mt-2">
                {post.mediaUrls.map((m, i) => (
                  <a key={i} href={m} target="_blank" className="text-xs underline break-all">{m}</a>
                ))}
              </div>
            )}
            <div className="mt-3 flex items-center gap-4 text-sm text-gray-600">
              <button className="inline-flex items-center gap-1 hover:text-indigo-600" onClick={() => onReact(post.id)}>
                <HeartIcon className="w-4 h-4" /> {post.likeCount}
              </button>
              <div className="inline-flex items-center gap-1">
                <MessagesSquareIcon className="w-4 h-4" /> {post.commentCount}
              </div>
              <div className="inline-flex items-center gap-1">
                <Share2Icon className="w-4 h-4" /> {post.shareCount}
              </div>
            </div>
            <div className="mt-3 flex gap-2">
              <Input
                value={commentDraft}
                onChange={e=>setCommentDraft(e.target.value)}
                placeholder="Write a comment..."
                className="h-9"
              />
              <Button onClick={submitComment} variant="secondary">Reply</Button>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

const FeedPage: React.FC = () => {
  const [user, setUser] = useState<any>(null);
  const [feed, setFeed] = useState<PostType[]>([]);
  const [cursor, setCursor] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    (async () => {
      try {
        // @ts-ignore
        const u = await User.me();
        setUser(u);
        await loadMore(null);
      } catch (e) {
        console.error(e);
      }
    })();
  }, []);

  const loadMore = async (c: string | null) => {
    if (loading) return;
    setLoading(true);
    try {
      const res = await Post.listFeed({ cursor: c ?? undefined, limit: 10 });
      setFeed(prev => c ? [...prev, ...res.items] : res.items);
      setCursor(res.nextCursor);
    } finally {
      setLoading(false);
    }
  };

  const handlePost = async (payload: any) => {
    const newPost = await Post.create(payload);
    setFeed(prev => [newPost, ...prev]);
  };

  const handleReact = async (id: string) => {
    await Post.react(id, "LIKE");
    setFeed(prev => prev.map(p => p.id === id ? { ...p, likeCount: p.likeCount + 1 } : p));
  };

  const handleComment = async (id: string, content: string) => {
    await Post.comment(id, content);
    setFeed(prev => prev.map(p => p.id === id ? { ...p, commentCount: p.commentCount + 1 } : p));
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-50 via-white to-blue-50 p-4 md:p-8">
      <div className="max-w-3xl mx-auto space-y-4">
        <PostComposer onPost={handlePost} user={user} />
        {feed.map((p) => (
          <motion.div key={p.id} initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }}>
            <PostCard post={p} onReact={handleReact} onComment={handleComment} />
          </motion.div>
        ))}
        <div className="flex justify-center py-6">
          {cursor ? (
            <Button onClick={() => loadMore(cursor!)} variant="outline" disabled={loading}>
              {loading ? "Loading..." : "Load more"}
            </Button>
          ) : (
            <span className="text-sm text-gray-500">You're all caught up</span>
          )}
        </div>
      </div>
    </div>
  );
};

export default FeedPage;

---

=== path: apps/web/src/router/routes.ts ===
/** Register Feed route (append to your routes) */
import Feed from "@/pages/Feed";
export const routes = [
  // ...other routes
  { path: "/feed", element: <Feed /> },
];

---

=== path: apps/web/src/components/ui/avatar.tsx ===
/** Minimal avatar (if you don't already have one) */
import * as React from "react";

export const Avatar = ({ children }: { children: React.ReactNode }) => (
  <div className="w-10 h-10 rounded-full bg-gray-200 flex items-center justify-center text-gray-700">{children}</div>
);
export const AvatarImage = ({ src }: { src?: string }) => null;
export const AvatarFallback = ({ children }: { children: React.ReactNode }) => <>{children}</>;

---

=== path: apps/web/src/lib/api.ts ===
/** Lightweight API wrapper */
export const api = {
  async get(path: string, params: Record<string, any> = {}) {
    const qs = new URLSearchParams(params as any).toString();
    const res = await fetch(`/api${path}${qs ? "?" + qs : ""}`, { credentials: "include" });
    if (!res.ok) throw new Error(await res.text());
    return res.json();
  },
  async post(path: string, body: any) {
    const res = await fetch(`/api${path}`, {
      method: "POST",
      credentials: "include",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    if (!res.ok) throw new Error(await res.text());
    return res.json();
  },
  async delete(path: string) {
    const res = await fetch(`/api${path}`, { method: "DELETE", credentials: "include" });
    if (!res.ok) throw new Error(await res.text());
    return res.json();
  },
};

---

=== path: apps/api/src/index.ts ===
/** Mount posts routes (append in your API bootstrap) */
import postsRouter from "@/routes/posts";
app.use("/api", postsRouter);